<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Keep Team">
    
    <title>
        
            面试 |
        
        Keep Theme
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Keep Theme","author":"Keep Team","avatar":"/images/avatar.svg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":false,"style":"default"},"highlight_theme":"default"},"toc":{"enable":false,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":false,"site_pv":false,"page_pv":false}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Keep Theme
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                HOME
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                ARCHIVES
                                
                            </a>
                            
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            HOME
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                            ARCHIVES
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        面试
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Keep Team</span>
                                
                                    <span class="author-badge">Lv4</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2025-02-10 16:41:43</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Mon May 19 2025 21:07:38 GMT+0800">2025-05-19 21:07:38</span>
            </span>
        

        

        

        
        
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <p><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/" >web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="节流和防抖讲一下？"><a href="#节流和防抖讲一下？" class="headerlink" title="节流和防抖讲一下？"></a>节流和防抖讲一下？</h4><p>以下是手写节流（Throttle）和防抖（Debounce）函数的详细实现及解析：</p>
<h3 id="一、防抖函数（Debounce）"><a href="#一、防抖函数（Debounce）" class="headerlink" title="一、防抖函数（Debounce）"></a><strong>一、防抖函数（Debounce）</strong></h3><p><strong>原理</strong>：在事件触发后，延迟执行回调函数，若在延迟期间再次触发事件，则重新计时。适用于需要将多次操作合并为一次的场景（如搜索框实时搜索、窗口 resize 事件）。</p>
<h4 id="1-基础实现"><a href="#1-基础实现" class="headerlink" title="1. 基础实现"></a><strong>1. 基础实现</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">300</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">// 定时器引用</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存调用上下文</span></span><br><span class="line"> <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除前一次定时器</span></span><br><span class="line"> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args); <span class="comment">// 延迟执行回调</span></span><br><span class="line"> &#125;, delay);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-带立即执行版本"><a href="#2-带立即执行版本" class="headerlink" title="2. 带立即执行版本"></a><strong>2. 带立即执行版本</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">300</span>, immediate = <span class="literal">false</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">let</span> lastExecTime = <span class="number">0</span>; <span class="comment">// 记录上次执行时间</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"> timer = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"> <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行模式：在首次触发时立即执行，之后进入延迟</span></span><br><span class="line"> <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> lastExecTime = now;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 计算剩余延迟时间（避免连续触发时延迟叠加）</span></span><br><span class="line"> <span class="keyword">const</span> remaining = delay - (now - lastExecTime);</span><br><span class="line"> <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> lastExecTime = now;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="title function_">clear</span>();</span><br><span class="line"> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> lastExecTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> &#125;, remaining);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a><strong>3. 使用示例</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索框防抖示例</span></span><br><span class="line"><span class="keyword">const</span> searchInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;search&#x27;</span>);</span><br><span class="line">searchInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title function_">debounce</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行搜索：&#x27;</span>, value);</span><br><span class="line">&#125;, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>

<h3 id="二、节流函数（Throttle）"><a href="#二、节流函数（Throttle）" class="headerlink" title="二、节流函数（Throttle）"></a><strong>二、节流函数（Throttle）</strong></h3><p><strong>原理</strong>：确保函数在指定时间内只执行一次，无论事件触发多少次。适用于需要控制执行频率的场景（如滚动事件、鼠标移动追踪）。</p>
<h4 id="1-时间戳版本（立即执行）"><a href="#1-时间戳版本（立即执行）" class="headerlink" title="1. 时间戳版本（立即执行）"></a><strong>1. 时间戳版本（立即执行）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, limit = <span class="number">300</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> lastExecTime = <span class="number">0</span>; <span class="comment">// 上次执行时间</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"> <span class="keyword">if</span> (now - lastExecTime &gt;= limit) &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> lastExecTime = now; <span class="comment">// 更新执行时间</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-定时器版本（延迟执行）"><a href="#2-定时器版本（延迟执行）" class="headerlink" title="2. 定时器版本（延迟执行）"></a><strong>2. 定时器版本（延迟执行）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, limit = <span class="number">300</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> timer = <span class="literal">null</span>; <span class="comment">// 重置定时器</span></span><br><span class="line"> &#125;, limit);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-混合版本（立即执行-延迟兜底）"><a href="#3-混合版本（立即执行-延迟兜底）" class="headerlink" title="3. 混合版本（立即执行 + 延迟兜底）"></a><strong>3. 混合版本（立即执行 + 延迟兜底）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, limit = <span class="number">300</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> lastExecTime = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"> <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> <span class="keyword">const</span> elapsed = now - lastExecTime;</span><br><span class="line"> <span class="comment">// 立即执行部分</span></span><br><span class="line"> <span class="keyword">if</span> (elapsed &gt;= limit) &#123;</span><br><span class="line"> <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> lastExecTime = now;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 延迟兜底部分（确保最后一次触发被执行）</span></span><br><span class="line"> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"> lastExecTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"> timer = <span class="literal">null</span>;</span><br><span class="line"> &#125;, limit - elapsed);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a><strong>4. 使用示例</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动事件节流示例</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;滚动位置：&#x27;</span>, <span class="variable language_">window</span>.<span class="property">scrollY</span>);</span><br><span class="line">&#125;, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>

<h3 id="三、核心区别对比"><a href="#三、核心区别对比" class="headerlink" title="三、核心区别对比"></a><strong>三、核心区别对比</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>防抖（Debounce）</strong></th>
<th><strong>节流（Throttle）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发时机</strong></td>
<td>最后一次触发事件后延迟执行</td>
<td>在指定时间内只执行一次</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>搜索框、表单验证、按钮防重复点击</td>
<td>滚动监听、鼠标移动、高频数据上报</td>
</tr>
<tr>
<td><strong>实现核心</strong></td>
<td>定时器（setTimeout）</td>
<td>时间戳或定时器</td>
</tr>
<tr>
<td><strong>执行次数</strong></td>
<td>事件停止触发后执行一次</td>
<td>事件持续触发时按固定频率执行</td>
</tr>
</tbody></table>
<h3 id="四、扩展优化"><a href="#四、扩展优化" class="headerlink" title="四、扩展优化"></a><strong>四、扩展优化</strong></h3><ol>
<li><p><strong>取消功能</strong>：允许手动取消未执行的回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> debounced = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">debounced.<span class="property">cancel</span> = <span class="function">() =&gt;</span> &#123; <span class="comment">// 添加取消方法</span></span><br><span class="line"><span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">timer = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回值处理</strong>：支持获取回调函数的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line"><span class="title function_">resolve</span>(result);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> promise; <span class="comment">// 返回 Promise</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3></li>
</ol>
<ul>
<li><strong>防抖</strong> 适合处理 <strong>低频操作</strong>，确保操作结束后执行一次（如用户输入完成后搜索）。</li>
<li><strong>节流</strong> 适合处理 <strong>高频操作</strong>，强制控制执行频率（如实时位置追踪）。</li>
<li>根据场景选择实现方式（时间戳或定时器），并注意内存泄漏问题（及时清除定时器）。</li>
</ul>
<h2 id="这里涉及到闭包问题，你讲一下闭包"><a href="#这里涉及到闭包问题，你讲一下闭包" class="headerlink" title="这里涉及到闭包问题，你讲一下闭包"></a>这里涉及到闭包问题，你讲一下闭包</h2><p>闭包（Closure）是 JavaScript 中非常重要的概念，也是理解 JavaScript 函数式编程和作用域链的关键。下面从定义、原理、作用、应用场景和注意事项等方面详细讲解闭包。</p>
<h3 id="一、闭包的定义"><a href="#一、闭包的定义" class="headerlink" title="一、闭包的定义"></a><strong>一、闭包的定义</strong></h3><p>闭包是指<strong>函数与其周围状态（词法环境）的引用捆绑在一起形成的组合</strong>。简单来说，<strong>闭包允许一个函数访问并记住其外层作用域的变量，即使外层函数已经执行完毕</strong>。<br>闭包的形成需要满足两个条件：</p>
<ol>
<li><p><strong>嵌套函数</strong>：在一个函数内部定义另一个函数。</p>
</li>
<li><p><strong>内部函数引用外部函数的变量</strong>：内部函数使用了外层函数的参数或变量。</p>
<h3 id="二、闭包的原理：作用域链与内存机制"><a href="#二、闭包的原理：作用域链与内存机制" class="headerlink" title="二、闭包的原理：作用域链与内存机制"></a><strong>二、闭包的原理：作用域链与内存机制</strong></h3><h4 id="1-作用域链（Scope-Chain）"><a href="#1-作用域链（Scope-Chain）" class="headerlink" title="1. 作用域链（Scope Chain）"></a>1. <strong>作用域链（Scope Chain）</strong></h4></li>
</ol>
<ul>
<li><p>函数在定义时会创建一个<strong>词法作用域</strong>，记录函数内部和外部可访问的变量。</p>
</li>
<li><p>当内部函数被调用时，会沿着作用域链向上查找外层函数的变量，即使外层函数已执行结束，内部函数仍能通过引用访问这些变量。</p>
<h4 id="2-内存机制"><a href="#2-内存机制" class="headerlink" title="2. 内存机制"></a>2. <strong>内存机制</strong></h4></li>
<li><p>外层函数执行完毕后，其作用域本应被 JavaScript 引擎回收，但由于闭包引用了外层变量，这些变量会被保留在内存中，直到闭包被销毁。</p>
<h3 id="三、闭包的作用"><a href="#三、闭包的作用" class="headerlink" title="三、闭包的作用"></a><strong>三、闭包的作用</strong></h3><h4 id="1-变量私有化（封装）"><a href="#1-变量私有化（封装）" class="headerlink" title="1. 变量私有化（封装）"></a>1. <strong>变量私有化（封装）</strong></h4><p>闭包可以将变量限制在函数内部，避免全局污染，实现类似“私有属性”的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 私有变量，外部无法直接访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 闭包函数</span></span><br><span class="line">count++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add = <span class="title function_">counter</span>();</span><br><span class="line"><span class="title function_">add</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">add</span>(); <span class="comment">// 2（闭包记住了 count 的状态）</span></span><br></pre></td></tr></table></figure>

<h4 id="2-保存状态"><a href="#2-保存状态" class="headerlink" title="2. 保存状态"></a>2. <strong>保存状态</strong></h4><p>闭包可以“记住”外层函数的执行状态，常用于需要持久化数据的场景（如计数器、定时器等）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTimer</span>(<span class="params">interval</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timerId;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (timerId) <span class="built_in">clearInterval</span>(timerId); <span class="comment">// 清除上一个定时器</span></span><br><span class="line">timerId = <span class="built_in">setInterval</span>(callback, interval); <span class="comment">// 保存当前定时器 ID</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myTimer = <span class="title function_">createTimer</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="title function_">myTimer</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tick&quot;</span>)); <span class="comment">// 每秒打印一次</span></span><br><span class="line"><span class="title function_">myTimer</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Changed&quot;</span>)); <span class="comment">// 清除前一个定时器，重新开始</span></span><br></pre></td></tr></table></figure>

<h4 id="3-函数柯里化（Currying）"><a href="#3-函数柯里化（Currying）" class="headerlink" title="3. 函数柯里化（Currying）"></a>3. <strong>函数柯里化（Currying）</strong></h4><p>通过闭包将多参数函数转换为单参数函数链，逐步处理参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add5 = <span class="title function_">add</span>(<span class="number">5</span>); <span class="comment">// 固定第一个参数为 5</span></span><br><span class="line"><span class="keyword">const</span> add5And10 = <span class="title function_">add5</span>(<span class="number">10</span>); <span class="comment">// 固定第二个参数为 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5And10</span>(<span class="number">15</span>)); <span class="comment">// 30（5 + 10 + 15）</span></span><br></pre></td></tr></table></figure>

<h3 id="四、闭包的经典应用场景"><a href="#四、闭包的经典应用场景" class="headerlink" title="四、闭包的经典应用场景"></a><strong>四、闭包的经典应用场景</strong></h3><h4 id="1-防抖与节流"><a href="#1-防抖与节流" class="headerlink" title="1. 防抖与节流"></a>1. <strong>防抖与节流</strong></h4><p>通过闭包保存定时器 ID 或上次执行时间，实现高频事件优化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖函数（闭包保存定时器 ID）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timeoutId;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"><span class="built_in">clearTimeout</span>(timeoutId); <span class="comment">// 清除上一次定时器</span></span><br><span class="line">timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-模块化开发"><a href="#2-模块化开发" class="headerlink" title="2. 模块化开发"></a>2. <strong>模块化开发</strong></h4><p>在 IIFE（立即执行函数表达式）中使用闭包实现模块私有方法和属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> privateData = <span class="string">&quot;secret&quot;</span>; <span class="comment">// 私有数据</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="title function_">getPrivateData</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> privateData; <span class="comment">// 闭包访问私有数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="title function_">getPrivateData</span>()); <span class="comment">// &quot;secret&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">privateData</span>); <span class="comment">// undefined（无法直接访问私有变量）</span></span><br></pre></td></tr></table></figure>

<h4 id="3-事件处理函数"><a href="#3-事件处理函数" class="headerlink" title="3. 事件处理函数"></a>3. <strong>事件处理函数</strong></h4><p>在循环中为每个元素绑定事件时，闭包可保存当前迭代变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：闭包共享同一个 i（ES5 环境）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">btn[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 点击时输出 3（所有按钮共享同一个 i）</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示例：通过闭包保存当前 i 的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">j</span>) &#123; <span class="comment">// 立即执行函数创建闭包，参数 j 接收当前 i 的值</span></span><br><span class="line">btn[j].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// 分别输出 0、1、2</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、闭包的注意事项"><a href="#五、闭包的注意事项" class="headerlink" title="五、闭包的注意事项"></a><strong>五、闭包的注意事项</strong></h3><h4 id="1-内存泄漏风险"><a href="#1-内存泄漏风险" class="headerlink" title="1. 内存泄漏风险"></a>1. <strong>内存泄漏风险</strong></h4></li>
<li><p>闭包会引用外层变量，若过度使用或未正确释放，可能导致内存占用过高。</p>
</li>
<li><p><strong>解决方案</strong>：不需要闭包时，手动将其设为 <code>null</code>，释放引用。</p>
<h4 id="2-变量作用域混淆"><a href="#2-变量作用域混淆" class="headerlink" title="2. 变量作用域混淆"></a>2. <strong>变量作用域混淆</strong></h4></li>
<li><p>注意区分函数定义时的作用域（词法作用域）和执行时的作用域，避免因作用域链查找错误导致逻辑问题。</p>
<h4 id="3-性能影响"><a href="#3-性能影响" class="headerlink" title="3. 性能影响"></a>3. <strong>性能影响</strong></h4></li>
<li><p>频繁创建闭包可能会影响内存性能，尤其是在循环或高频操作中，需谨慎使用。</p>
<h3 id="六、闭包与-ES6-块级作用域（let-const）"><a href="#六、闭包与-ES6-块级作用域（let-const）" class="headerlink" title="六、闭包与 ES6 块级作用域（let&#x2F;const）"></a><strong>六、闭包与 ES6 块级作用域（let&#x2F;const）</strong></h3><p>在 ES6 中，<code>let</code> 和 <code>const</code> 声明的变量具有块级作用域，循环中的闭包问题可更简洁地解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// let 声明的 i 在每次循环中都是新的变量</span></span><br><span class="line">btn[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 分别输出 0、1、2（每个闭包绑定独立的 i）</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>let</code> 声明的 <code>i</code> 在每次循环迭代中会创建新的绑定，闭包会正确捕获当前迭代的值，无需额外的 IIFE。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>闭包是 JavaScript 的核心特性，本质是<strong>函数对其词法作用域的引用</strong>。合理使用闭包可以实现变量封装、状态保存等强大功能，但需注意内存管理和作用域问题。理解闭包有助于深入掌握 JavaScript 的异步编程、模块化开发等高级主题。</p>
</li>
</ul>
<h2 id="讲一下内存泄漏"><a href="#讲一下内存泄漏" class="headerlink" title="讲一下内存泄漏"></a>讲一下内存泄漏</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/JavaScript/memory_leak.html" >面试官：说说 JavaScript 中内存泄漏的几种情况？ | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="最后一次滚动经常必须出发事件，怎么跳过这个时间验证兜底？"><a href="#最后一次滚动经常必须出发事件，怎么跳过这个时间验证兜底？" class="headerlink" title="最后一次滚动经常必须出发事件，怎么跳过这个时间验证兜底？"></a>最后一次滚动经常必须出发事件，怎么跳过这个时间验证兜底？</h2><p>在滚动事件中，为了确保“最后一次滚动”一定触发事件（即使未达到节流&#x2F;防抖的时间间隔），可以通过<strong>时间戳+定时器的混合模式</strong>实现“兜底”逻辑。以下是具体解决方案：</p>
<h3 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a><strong>一、问题分析</strong></h3><p>传统的节流&#x2F;防抖会因时间间隔限制，可能导致<strong>最后一次滚动事件未被触发</strong>（例如用户快速停止滚动时，剩余时间未达到阈值）。解决方案需要：</p>
<ol>
<li><p><strong>立即执行最后一次操作</strong>：确保滚动停止时强制触发事件。</p>
</li>
<li><p><strong>保留频率控制</strong>：在滚动过程中按频率触发，避免性能问题。</p>
<h3 id="二、混合模式节流函数（带兜底触发）"><a href="#二、混合模式节流函数（带兜底触发）" class="headerlink" title="二、混合模式节流函数（带兜底触发）"></a><strong>二、混合模式节流函数（带兜底触发）</strong></h3><h4 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a><strong>核心逻辑</strong></h4></li>
</ol>
<ul>
<li><p><strong>时间戳模式</strong>：在滚动过程中，按固定间隔（如<code>300ms</code>）立即触发事件。</p>
</li>
<li><p><strong>定时器兜底</strong>：在滚动停止时，通过定时器确保最后一次事件触发。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttleWithLastCall</span>(<span class="params">fn, limit = <span class="number">300</span></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> lastExecTime = <span class="number">0</span>; <span class="comment">// 上次执行时间</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">// 兜底定时器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"><span class="comment">// 立即执行部分：满足时间间隔时触发</span></span><br><span class="line"> <span class="keyword">if</span> (now - lastExecTime &gt;= limit) &#123;</span><br><span class="line"> <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除兜底定时器</span></span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args); <span class="comment">// 执行事件</span></span><br><span class="line"> lastExecTime = now; <span class="comment">// 更新时间戳</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 兜底部分：滚动停止时触发最后一次事件</span></span><br><span class="line"> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> fn.<span class="title function_">apply</span>(context, args); <span class="comment">// 触发最后一次事件</span></span><br><span class="line"> lastExecTime = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 重置时间戳</span></span><br><span class="line"> timer = <span class="literal">null</span>; <span class="comment">// 清除定时器</span></span><br><span class="line"> &#125;, limit - (now - lastExecTime)); <span class="comment">// 计算剩余时间</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">const</span> scrollHandler = <span class="title function_">throttleWithLastCall</span>(<span class="function">(<span class="params">scrollY</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前滚动位置：&#x27;</span>, scrollY);</span><br><span class="line">&#125;, <span class="number">300</span>); <span class="comment">// 300ms 频率，最后一次滚动必触发</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="title function_">scrollHandler</span>(<span class="variable language_">window</span>.<span class="property">scrollY</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-区分普通触发与兜底触发"><a href="#2-区分普通触发与兜底触发" class="headerlink" title="2. 区分普通触发与兜底触发"></a><strong>2. 区分普通触发与兜底触发</strong></h4><p>如需标记是否为“兜底触发”，可通过参数传递状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttleWithLastCall</span>(<span class="params">fn, limit = <span class="number">300</span></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">fn.<span class="title function_">apply</span>(context, [...args, &#123; <span class="attr">isLast</span>: <span class="literal">true</span> &#125;]); <span class="comment">// 传递兜底标记</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;, ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用时判断</span></span><br><span class="line"><span class="title function_">scrollHandler</span>(<span class="function">(<span class="params">scrollY, &#123; isLast &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isLast) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最后一次滚动&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-性能平衡"><a href="#3-性能平衡" class="headerlink" title="3. 性能平衡"></a><strong>3. 性能平衡</strong></h4><ul>
<li><p><strong><code>limit</code>不宜过小</strong>：过小的时间间隔会导致兜底触发频繁，失去意义（建议≥100ms）。</p>
</li>
<li><p><strong>避免过度回调</strong>：若兜底触发仍过于频繁，可结合业务需求调整逻辑（如设置最小触发间隔）。</p>
<h3 id="六、对比传统方案"><a href="#六、对比传统方案" class="headerlink" title="六、对比传统方案"></a><strong>六、对比传统方案</strong></h3><table>
<thead>
<tr>
<th><strong>方案</strong></th>
<th>最后一次触发</th>
<th>滚动中频率控制</th>
<th>实现复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>纯时间戳节流</strong></td>
<td>不保证</td>
<td>优</td>
<td>简单</td>
</tr>
<tr>
<td><strong>纯定时器节流</strong></td>
<td>保证</td>
<td>事件延迟触发</td>
<td>简单</td>
</tr>
<tr>
<td><strong>混合模式</strong></td>
<td><strong>保证</strong></td>
<td>立即触发+兜底</td>
<td>中等</td>
</tr>
</tbody></table>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过混合使用时间戳和定时器，既能在滚动过程中按频率高效触发事件，又能确保最后一次滚动一定触发回调。此方案适用于需要实时反馈（如滚动加载、实时位置显示）且必须捕获最终状态的场景，平衡了性能与功能完整性。</p>
</li>
</ul>
<h2 id="你提到了-vue2-和-vue3，它们有什么区别？"><a href="#你提到了-vue2-和-vue3，它们有什么区别？" class="headerlink" title="你提到了 vue2 和 vue3，它们有什么区别？"></a>你提到了 vue2 和 vue3，它们有什么区别？</h2><ul>
<li>[vue2和vue3](<a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/vue3_vue2.html" >面试官：vue3有了解过吗？能说说跟vue2的区别吗？ | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a>)</li>
</ul>
<p>Vue 2 和 Vue 3 是 Vue.js 框架的两个主要版本，两者在设计理念、性能、功能特性和开发体验等方面有显著区别。以下是核心差异的详细对比：</p>
<h3 id="一、响应式原理"><a href="#一、响应式原理" class="headerlink" title="一、响应式原理"></a><strong>一、响应式原理</strong></h3><h4 id="Vue-2"><a href="#Vue-2" class="headerlink" title="Vue 2"></a><strong>Vue 2</strong></h4><ul>
<li><p><strong>实现方式</strong>：基于 **Object.defineProperty()**，通过劫持对象的 <code>get</code>&#x2F;<code>set</code> 方法实现响应式。</p>
</li>
<li><p><strong>局限性</strong>：</p>
<ul>
<li><p>无法检测对象属性的新增或删除（需手动调用 <code>Vue.set</code> 或 <code>this.$set</code>）。</p>
</li>
<li><p>数组的某些变异方法（如 <code>push</code>&#x2F;<code>splice</code>）需要重写才能触发更新。</p>
</li>
<li><p>嵌套对象的响应式需要深度遍历，性能较低。</p>
<h4 id="Vue-3"><a href="#Vue-3" class="headerlink" title="Vue 3"></a><strong>Vue 3</strong></h4></li>
</ul>
</li>
<li><p><strong>实现方式</strong>：基于 <strong>Proxy</strong>（ES6 原生代理），直接代理整个对象，而非逐个属性劫持。</p>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li><p>可直接检测对象属性的新增&#x2F;删除（无需 <code>Vue.set</code>）。</p>
</li>
<li><p>原生支持数组索引和长度变化的响应式。</p>
</li>
<li><p>响应式数据包裹更灵活（通过 <code>reactive</code>&#x2F;<code>ref</code> 函数），且嵌套对象无需深度遍历，性能更高。</p>
<h3 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a><strong>二、性能优化</strong></h3><h4 id="Vue-2-1"><a href="#Vue-2-1" class="headerlink" title="Vue 2"></a><strong>Vue 2</strong></h4></li>
</ul>
</li>
<li><p>采用 <strong>虚拟 DOM diff 算法</strong>，但在大型应用中，依赖收集和更新范围可能不够精准。</p>
<h4 id="Vue-3-1"><a href="#Vue-3-1" class="headerlink" title="Vue 3"></a><strong>Vue 3</strong></h4></li>
<li><p><strong>优化点</strong>：</p>
<ul>
<li><strong>更快的虚拟 DOM diff</strong>：基于“最长递增子序列”算法，减少不必要的 DOM 操作。</li>
<li><strong>编译时优化</strong>：通过 <code>compileStatic</code> 标记静态节点，渲染时直接跳过 diff。</li>
<li>** Fragment 支持**：组件可返回多个根节点（无需包裹 <code>&lt;div&gt;</code>），减少冗余 DOM。</li>
<li><strong>响应式缓存优化</strong>：按需收集依赖，避免无效触发更新。</li>
</ul>
</li>
<li><p><strong>性能提升</strong>：相比 Vue 2，初始化渲染速度提升约 **55%**，更新速度提升约 **133%**（官方数据）。</p>
<h3 id="三、API-设计"><a href="#三、API-设计" class="headerlink" title="三、API 设计"></a><strong>三、API 设计</strong></h3><h4 id="选项式-API（Options-API）"><a href="#选项式-API（Options-API）" class="headerlink" title="选项式 API（Options API）"></a><strong>选项式 API（Options API）</strong></h4></li>
<li><p><strong>Vue 2&#x2F;3 均支持</strong>，但 Vue 3 对其进行了增强：</p>
<ul>
<li><p>新增 <code>setup</code> 选项（组合式 API 的入口）。</p>
</li>
<li><p><code>data</code> 选项可直接返回对象（无需函数）。</p>
<h4 id="组合式-API（Composition-API）"><a href="#组合式-API（Composition-API）" class="headerlink" title="组合式 API（Composition API）"></a><strong>组合式 API（Composition API）</strong></h4></li>
</ul>
</li>
<li><p><strong>Vue 3 新增核心特性</strong>，基于函数式编程思想：</p>
<ul>
<li><p><strong>逻辑复用更灵活</strong>：通过自定义 Hook 函数（如 <code>useMousePosition</code>）复用逻辑，避免 Vue 2 中 <code>mixins</code> 的命名冲突和逻辑割裂问题。</p>
</li>
<li><p><strong>响应式更直观</strong>：使用 <code>ref</code>&#x2F;<code>reactive</code> 显式创建响应式数据，搭配 <code>watch</code>&#x2F;<code>computed</code> 实现响应式逻辑。</p>
</li>
<li><p><strong>更好的类型推导</strong>：对 TypeScript 支持更友好，函数参数和返回值类型可直接推断。</p>
<h4 id="对比示例"><a href="#对比示例" class="headerlink" title="对比示例"></a><strong>对比示例</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">Vue</span> <span class="number">2</span>（选项式 <span class="variable constant_">API</span>） --&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125; &#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123; <span class="title function_">increment</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">count</span>++ &#125; &#125;,</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- <span class="title class_">Vue</span> <span class="number">3</span>（组合式 <span class="variable constant_">API</span>） --&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; count.<span class="property">value</span>++;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>));</span><br><span class="line"><span class="keyword">return</span> &#123; count, increment &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、组件与生态"><a href="#四、组件与生态" class="headerlink" title="四、组件与生态"></a><strong>四、组件与生态</strong></h3><h4 id="组件语法"><a href="#组件语法" class="headerlink" title="组件语法"></a><strong>组件语法</strong></h4></li>
</ul>
</li>
<li><p><strong>Vue 3</strong> 支持 <strong>Teleport</strong>（传送门）和 <strong>Suspense</strong>（异步组件加载）：</p>
<ul>
<li><p><code>Teleport</code> 可将组件内容渲染到 DOM 树的任意位置（如弹窗挂载到 <code>body</code> 下）。</p>
</li>
<li><p><code>Suspense</code> 可优雅处理异步组件的加载状态（如 <code>loading</code>&#x2F;<code>error</code> 状态）。</p>
<h4 id="生态兼容性"><a href="#生态兼容性" class="headerlink" title="生态兼容性"></a><strong>生态兼容性</strong></h4></li>
</ul>
</li>
<li><p><strong>Vue 2</strong>：依赖 <code>vue-router@3</code>、<code>vuex@3</code> 等旧版本库。</p>
</li>
<li><p><strong>Vue 3</strong>：官方库全面升级（如 <code>vue-router@4</code>、<code>pinia</code> 替代 <code>vuex</code>），且提供了 <code>@vue/compat</code> 兼容包，可逐步迁移旧项目。</p>
<h3 id="五、其他重要差异"><a href="#五、其他重要差异" class="headerlink" title="五、其他重要差异"></a><strong>五、其他重要差异</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Vue 2</strong></th>
<th><strong>Vue 3</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>全局 API</strong></td>
<td>挂载在 <code>Vue</code> 构造函数上（如 <code>Vue.component</code>）</td>
<td>通过 <code>createApp</code> 函数创建应用实例（更模块化）</td>
</tr>
<tr>
<td><strong>自定义指令钩子</strong></td>
<td><code>bind</code>&#x2F;<code>inserted</code>&#x2F;<code>update</code> 等</td>
<td>统一为 <code>beforeMount</code>&#x2F;<code>mounted</code>&#x2F;<code>beforeUpdate</code> 等（与组件生命周期对齐）</td>
</tr>
<tr>
<td><strong>Fragment 支持</strong></td>
<td>不支持（需单根节点）</td>
<td>支持（组件可返回多个根节点）</td>
</tr>
<tr>
<td><strong>Tree-shaking</strong></td>
<td>部分支持（需手动配置）</td>
<td>原生支持（打包时自动移除未使用的 API）</td>
</tr>
<tr>
<td><strong>TypeScript 支持</strong></td>
<td>需额外配置</td>
<td>内置完善的类型定义（第一类公民）</td>
</tr>
</tbody></table>
<h3 id="如何选择版本？"><a href="#如何选择版本？" class="headerlink" title="如何选择版本？"></a><strong>如何选择版本？</strong></h3></li>
<li><p><strong>新项目&#x2F;团队</strong>：优先选择 <strong>Vue 3</strong>，利用组合式 API 和性能优势，尤其适合中大型应用或需要 TypeScript 的场景。</p>
</li>
<li><p><strong>旧项目维护</strong>：若项目复杂且迁移成本高，可继续使用 <strong>Vue 2</strong>，但建议逐步规划升级（通过 <code>@vue/compat</code> 过渡）。</p>
</li>
<li><p><strong>生态考量</strong>：Vue 3 的新生态（如 <code>Vite</code>、<code>Pinia</code>）更现代，开发体验更优，而 Vue 2 生态趋于稳定但更新缓慢。<br>总之，Vue 3 通过响应式机制升级、组合式 API 和性能优化，解决了 Vue 2 的诸多痛点，是未来的主流方向。</p>
</li>
</ul>
<h2 id="谈一谈-vue3-的事件传递机制？"><a href="#谈一谈-vue3-的事件传递机制？" class="headerlink" title="谈一谈 vue3 的事件传递机制？"></a>谈一谈 vue3 的事件传递机制？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/2503_90377662/article/details/147620153?spm=1011.2415.3001.5331" >事件传递机制<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="讲讲重绘重排？"><a href="#讲讲重绘重排？" class="headerlink" title="讲讲重绘重排？"></a>讲讲重绘重排？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/2503_90377662/article/details/147571203?spm=1011.2415.3001.5331" >重绘重排<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="为什么-maven-使用自动更新依赖的机制，但是-vue-不使用？"><a href="#为什么-maven-使用自动更新依赖的机制，但是-vue-不使用？" class="headerlink" title="为什么 maven 使用自动更新依赖的机制，但是 vue 不使用？"></a>为什么 maven 使用自动更新依赖的机制，但是 vue 不使用？</h2><ul>
<li>工具定位不同，npm 是包管理工具，maven 是依赖管理工具，package 声明了依赖，但是实际版本信息会被 package-lock.json 锁定，这是为了确保以来的稳定性，防止自动更新造成的不兼容不稳定的问题</li>
</ul>
<p>工具定位不同： vue 是包管理工具 maven 是依赖管理工具</p>
<p>Vue 项目中的 <code>package.json</code> 文件虽然声明了依赖，但包的实际版本信息会被 <code>package-lock.json</code> 或 <code>yarn.lock</code> 锁定。这些锁文件是为了确保依赖版本的稳定性，防止自动更新带来不兼容或不稳定的问题，因此避免了在每次运行时自动更新依赖版本。</p>
<h2 id="毕设管理系统怎么解决的跨域问题？"><a href="#毕设管理系统怎么解决的跨域问题？" class="headerlink" title="毕设管理系统怎么解决的跨域问题？"></a>毕设管理系统怎么解决的跨域问题？</h2><ul>
<li>我是采用的配置代理服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">   <span class="attr">proxy</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;/api/&#x27;</span>: &#123;</span><br><span class="line">       <span class="comment">//target: &#x27;http://192.168.1.31:8855&#x27;,</span></span><br><span class="line">       <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">       <span class="attr">changeOrigin</span>: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>后端也可以解决跨域问题,可以直接配置全部的跨域请求，也能设置某些接口的跨域 @CrossOrigin(origins &#x3D; “<a class="link"   target="_blank" rel="noopener" href="http://localhost:3000" ">http://localhost:3000"<i class="fas fa-external-link-alt"></i></a>)</p>
</li>
<li><pre><code class="java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer &#123;
@Override
public void addCorsMappings(CorsRegistry registry) &#123;
    // 配置允许跨域的路径，支持的请求方法，允许的来源等
    registry.addMapping(&quot;/**&quot;) // 允许所有路径进行跨域请求
            .allowedOrigins(&quot;http://localhost:3000&quot;) // 允许的域名，这里是前端地址
            .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;) // 允许的请求方法
            .allowedHeaders(&quot;*&quot;) // 允许的请求头
            .allowCredentials(true) // 是否允许携带 Cookie
            .maxAge(3600); // 缓存 CORS 配置的时间，单位是秒
&#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 最后我才用的还是前端解决，因为如果后端开启了广泛的 CORS 配置（例如允许所有域名 `*` 访问），就会造成潜在的安全隐患，尤其是在生产环境中。如果 CORS 配置不当，可能导致恶意网站访问你的 API，带来跨站脚本攻击（XSS）等安全风险。由后端直接解决跨域需要更加小心，确保跨域配置的安全性。而来也是希望后端更专注于业务逻辑的开发</span><br><span class="line"></span><br><span class="line">在 Vue 项目（如 Vue CLI 或 Vite 项目）中，`vue.config.js` 或 `vite.config.ts` 中的 `server.proxy` 配置通过 **代理服务器（Proxy）** 解决跨域问题。以下是其核心原理和配置解析：</span><br><span class="line"></span><br><span class="line">### **一、跨域问题的本质**</span><br><span class="line"></span><br><span class="line">浏览器的 **同源策略（Same-Origin Policy）** 限制非同源请求（协议、域名、端口任意一项不同）。例如：</span><br><span class="line"></span><br><span class="line">- 前端运行在 `http://localhost:8080`（前端域名/端口）</span><br><span class="line"></span><br><span class="line">- 后端 API 接口在 `http://localhost:8081`（后端域名/端口）</span><br><span class="line">  此时，前端直接请求 `http://localhost:8081/api` 会触发跨域错误。</span><br><span class="line">  </span><br><span class="line">  ### **二、代理服务器的核心原理**</span><br><span class="line">  </span><br><span class="line">  代理服务器作为前端和后端之间的 **中间层**，实现以下流程：</span><br><span class="line">1. 前端向 **同源地址**（如 `http://localhost:8080/api`）发起请求。</span><br><span class="line"></span><br><span class="line">2. 代理服务器接收请求后，将其转发到 **真实的后端地址**（如 `http://localhost:8081/api`）。</span><br><span class="line"></span><br><span class="line">3. 后端返回数据给代理服务器，再由代理服务器转发给前端。 **关键点**：由于前端和代理服务器属于 **同源**（同域名、同端口），浏览器允许这种请求，从而绕过跨域限制。</span><br><span class="line">   </span><br><span class="line">   ### **三、配置解析（以 Vue CLI 为例）**</span><br><span class="line">   </span><br><span class="line">   ```javascript</span><br><span class="line">   // vue.config.js</span><br><span class="line">   module.exports = &#123;</span><br><span class="line">   devServer: &#123; // Vue CLI 3+ 的代理配置</span><br><span class="line">   proxy: &#123;</span><br><span class="line">   &#x27;/api/&#x27;: &#123; // 匹配以 `/api/` 开头的请求路径</span><br><span class="line">   target: &#x27;http://localhost:8081&#x27;, // 真实后端地址（跨域的目标地址）</span><br><span class="line">   changeOrigin: true, // 关键配置！</span><br><span class="line">   // 其他可选配置</span><br><span class="line">   pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;, // 路径重写：去除请求路径中的 `/api` 前缀</span><br><span class="line">   secure: false, // 是否允许代理到 HTTPS 目标</span><br><span class="line">   ws: true // 是否代理 WebSocket 请求</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
 
 ### **四、关键配置项说明**
 
 #### 1. `changeOrigin: true`
</code></pre>
</li>
<li><p><strong>作用</strong>：让代理服务器在转发请求时，修改请求头中的 <code>Host</code> 字段，使其与 <code>target</code> 一致。</p>
</li>
<li><p><strong>场景</strong>：当后端需要根据 <code>Host</code> 字段判断请求来源时（如多个域名共享一个后端），必须设置为 <code>true</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><p>前端请求：<code>http://localhost:8080/api/user</code></p>
</li>
<li><p>代理后请求：<code>http://localhost:8081/user</code>（<code>Host</code> 头为 <code>localhost:8081</code>）</p>
<h4 id="2-pathRewrite"><a href="#2-pathRewrite" class="headerlink" title="2. pathRewrite"></a>2. <code>pathRewrite</code></h4></li>
</ul>
</li>
<li><p><strong>作用</strong>：修改请求路径，避免前端路径与后端路径产生冗余。</p>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><p>若后端接口实际路径为 <code>http://localhost:8081/user</code>，但前端习惯以 <code>/api</code> 作为前缀发起请求（如 <code>http://localhost:8080/api/user</code>），可通过 <code>pathRewrite</code> 去除前缀：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pathRewrite</span>: &#123;</span><br><span class="line"><span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">// 匹配路径开头的 `/api`，替换为空字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终代理请求路径为：<code>http://localhost:8081/user</code></p>
<h4 id="3-路径匹配规则"><a href="#3-路径匹配规则" class="headerlink" title="3. 路径匹配规则"></a>3. 路径匹配规则</h4></li>
</ul>
</li>
<li><p><strong>精确匹配</strong>：若配置 <code>&#39;/api&#39;</code>（不带 <code>/</code> 结尾），则仅匹配 <strong>完全等于 <code>/api</code></strong> 的路径（很少用）。</p>
</li>
<li><p><strong>前缀匹配</strong>：若配置 <code>&#39;/api/&#39;</code>（带 <code>/</code> 结尾），则匹配所有以 <code>/api/</code> 开头的路径（推荐写法）。</p>
<h3 id="五、代理的适用场景"><a href="#五、代理的适用场景" class="headerlink" title="五、代理的适用场景"></a><strong>五、代理的适用场景</strong></h3></li>
</ul>
<ol>
<li><p><strong>开发环境（Dev Server）</strong>：</p>
<ul>
<li>仅在本地开发时生效（<code>npm run serve</code>），打包后的生产环境需通过后端配置 CORS 或 Nginx 代理。</li>
</ul>
</li>
<li><p><strong>生产环境</strong>：</p>
<ul>
<li><p>需在后端服务器（如 Node.js、Nginx）中配置反向代理，而非依赖前端的代理配置。</p>
</li>
<li><p><strong>Nginx 示例</strong>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> your-domain.com;</span><br><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://backend-server:8081; // 代理到后端</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>; // 传递真实 <span class="attribute">Host</span> 头</span><br><span class="line">proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; // 传递客户端 <span class="attribute">IP</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、常见问题与解决方案"><a href="#六、常见问题与解决方案" class="headerlink" title="六、常见问题与解决方案"></a><strong>六、常见问题与解决方案</strong></h3><h4 id="1-代理无效，仍报跨域错误"><a href="#1-代理无效，仍报跨域错误" class="headerlink" title="1. 代理无效，仍报跨域错误"></a>1. 代理无效，仍报跨域错误</h4></li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>可能原因</strong>：</p>
<ul>
<li>未正确配置 <code>target</code> 地址（如 IP&#x2F;端口错误）。</li>
<li><code>changeOrigin</code> 未设置为 <code>true</code>，导致后端识别到跨域来源。</li>
<li>请求路径未匹配代理规则（如路径前缀写错）。</li>
</ul>
</li>
<li><p><strong>排查方法</strong>：</p>
<ul>
<li><p>在浏览器开发者工具中查看请求 URL，确认是否走代理（如 URL 显示为 <code>http://localhost:8080/api/...</code> 则走代理）。</p>
</li>
<li><p>检查后端是否返回正确的响应头（如 <code>Access-Control-Allow-Origin</code>），若代理未生效，可能需后端配合开启 CORS。</p>
<h4 id="2-生产环境跨域问题"><a href="#2-生产环境跨域问题" class="headerlink" title="2. 生产环境跨域问题"></a>2. 生产环境跨域问题</h4></li>
</ul>
</li>
<li><p><strong>原因</strong>：前端代理仅在开发环境生效，生产环境需后端配置 CORS 或通过服务器代理。</p>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><p>后端添加 CORS 响应头（推荐）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Express 示例</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); <span class="comment">// 允许所有来源</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET, POST, PUT, DELETE&#x27;</span>);</span><br><span class="line"><span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在生产环境服务器（如 Nginx）中配置反向代理。</p>
<h4 id="3-代理后接口返回-404"><a href="#3-代理后接口返回-404" class="headerlink" title="3. 代理后接口返回 404"></a>3. 代理后接口返回 404</h4></li>
</ul>
</li>
<li><p><strong>可能原因</strong>：路径重写错误，导致代理后的 URL 与后端实际路径不匹配。</p>
</li>
<li><p><strong>解决方案</strong>：调整 <code>pathRewrite</code> 配置，确保去除的前缀与前端请求路径一致。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>前端代理（<code>server.proxy</code>）是开发环境中解决跨域的便捷方案，核心原理是通过同源的代理服务器转发请求。生产环境需结合后端 CORS 或服务器代理实现跨域。配置时需注意路径匹配规则、<code>changeOrigin</code> 和 <code>pathRewrite</code> 的正确使用，以确保请求正确转发。</p>
</li>
</ul>
<h2 id="还有什么跨域解决方案吗？"><a href="#还有什么跨域解决方案吗？" class="headerlink" title="还有什么跨域解决方案吗？"></a>还有什么跨域解决方案吗？</h2><ul>
<li><p>jsonp</p>
</li>
<li><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/2503_90377662/article/details/147935022?spm=1011.2415.3001.5331" >JSONP-CSDN博客<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="你在项目中提到使用-HappyPack-与-DllPlugin-提升打包速度。请详细说明它们的原理、应用场景、Webpack5-中是否还推荐使用？为什么？"><a href="#你在项目中提到使用-HappyPack-与-DllPlugin-提升打包速度。请详细说明它们的原理、应用场景、Webpack5-中是否还推荐使用？为什么？" class="headerlink" title="你在项目中提到使用 HappyPack 与 DllPlugin 提升打包速度。请详细说明它们的原理、应用场景、Webpack5 中是否还推荐使用？为什么？"></a>你在项目中提到使用 HappyPack 与 DllPlugin 提升打包速度。请详细说明它们的原理、应用场景、Webpack5 中是否还推荐使用？为什么？</h2><ul>
<li><p>关于HappyPack：是基于Node.js的chile_process模块，通常用于babel-loader,ts-loader,css-loader等耗时操作，但是这个HappyPack已经不推荐使用了，Webpack5官方已经停止维护，实际开发中这个性能提升不明显，反而多开几个进程会提高IPC进程开销。</p>
</li>
<li><p>DllPlugin会将不会频繁改变的第三方库（React,vue,loadsh）打包成一个动态链接库，避免每次构建的时候重复编译，然后由DllReferencePlugin在主项目引入这些DLL，提高构建效率，但是维护成本比较高每次变化都要重新构建DLL。</p>
</li>
</ul>
<h2 id="你刚提到-HappyPack-和-DllPlugin-用于性能优化，但它们的核心场景是构建时间优化。-影响-Web-首屏加载性能的主要瓶颈有哪些？你是如何在实际中优化它们的？除了路由懒加载，还有哪些手段能有效缩短白屏时间？请尽量从资源体积、网络传输、解析渲染多个维度来思考，不止限于代码层面。"><a href="#你刚提到-HappyPack-和-DllPlugin-用于性能优化，但它们的核心场景是构建时间优化。-影响-Web-首屏加载性能的主要瓶颈有哪些？你是如何在实际中优化它们的？除了路由懒加载，还有哪些手段能有效缩短白屏时间？请尽量从资源体积、网络传输、解析渲染多个维度来思考，不止限于代码层面。" class="headerlink" title="你刚提到 HappyPack 和 DllPlugin 用于性能优化，但它们的核心场景是构建时间优化。 影响 Web 首屏加载性能的主要瓶颈有哪些？你是如何在实际中优化它们的？除了路由懒加载，还有哪些手段能有效缩短白屏时间？请尽量从资源体积、网络传输、解析渲染多个维度来思考，不止限于代码层面。"></a>你刚提到 HappyPack 和 DllPlugin 用于性能优化，但它们的核心场景是<strong>构建时间优化</strong>。 影响 Web 首屏加载性能的主要瓶颈有哪些？你是如何在实际中优化它们的？除了路由懒加载，还有哪些手段能有效缩短白屏时间？请尽量从资源体积、网络传输、解析渲染多个维度来思考，不止限于代码层面。</h2><ul>
<li><p>首屏加载瓶颈主要早四个方面：</p>
<ol>
<li><p>资源加载时间长（NetWork层面）</p>
<ul>
<li><p>JS&#x2F;CSS&#x2F;图片体积大或者并发少。</p>
</li>
<li><p>资源压缩不充分（未gzip,未brotli）.</p>
</li>
<li><p>网络请求阻塞（DNS,SSL，重定向等）</p>
</li>
</ul>
</li>
<li><p>JS解析执行慢（Parse&#x2F;compile&#x2F;Exec层）</p>
<ul>
<li><p>js打包后体积大，导致下载+解压+执行时间边长</p>
</li>
<li><p>单页面引用一开始下载了太多的组件逻辑</p>
</li>
</ul>
</li>
<li><p>DOM构建 + 样式层叠深，</p>
<ul>
<li><p>使用了复杂的布局或者动画</p>
</li>
<li><p>页面复杂度较高</p>
</li>
</ul>
</li>
<li><p>白屏时没有视觉反馈</p>
<ul>
<li>用户打开页面看到一片空白</li>
</ul>
</li>
</ol>
</li>
<li><p>解决方法：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>优化策略</th>
<th>技术说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>资源加载优化</strong></td>
<td>路由懒加载 &#x2F; 组件懒加载</td>
<td><code>import()</code> 配合 Webpack 的 code splitting</td>
</tr>
<tr>
<td></td>
<td>Tree Shaking</td>
<td>移除未引用代码（需 ESM）</td>
</tr>
<tr>
<td></td>
<td>压缩与缓存</td>
<td>gzip、brotli、cache-control</td>
</tr>
<tr>
<td><strong>执行优化</strong></td>
<td>Webpack SplitChunks</td>
<td>将业务逻辑和第三方库分包加载</td>
</tr>
<tr>
<td></td>
<td>动态 import + prefetch&#x2F;preload</td>
<td>控制资源异步加载或提前预加载</td>
</tr>
<tr>
<td><strong>渲染优化</strong></td>
<td>Skeleton Screen（骨架屏）</td>
<td>避免用户看到“白板”，提升感知性能</td>
</tr>
<tr>
<td></td>
<td>SSR + Hydration</td>
<td>服务端渲染首屏 HTML，客户端再激活</td>
</tr>
<tr>
<td></td>
<td>Lazy hydration &#x2F; Island 架构</td>
<td>渐进式激活组件（前端微模块）</td>
</tr>
<tr>
<td><strong>其他</strong></td>
<td>使用 Lighthouse 或 Web Vitals 分析瓶颈</td>
<td>数据驱动优化，而非盲目优化</td>
</tr>
</tbody></table>
<h2 id="如何控制-bundle-拆分粒度？拆分太多会反而增加-HTTP-开销，如何权衡？"><a href="#如何控制-bundle-拆分粒度？拆分太多会反而增加-HTTP-开销，如何权衡？" class="headerlink" title="如何控制 bundle 拆分粒度？拆分太多会反而增加 HTTP 开销，如何权衡？"></a>如何控制 bundle 拆分粒度？拆分太多会反而增加 HTTP 开销，如何权衡？</h2><h2 id="preload-vs-prefetch-的区别是什么？用错可能适得其反。"><a href="#preload-vs-prefetch-的区别是什么？用错可能适得其反。" class="headerlink" title="preload vs prefetch 的区别是什么？用错可能适得其反。"></a>preload vs prefetch 的区别是什么？用错可能适得其反。</h2><h2 id="你是否了解-Quicklink、SW（Service-Worker）对首屏加载的加速作用？"><a href="#你是否了解-Quicklink、SW（Service-Worker）对首屏加载的加速作用？" class="headerlink" title="你是否了解 Quicklink、SW（Service Worker）对首屏加载的加速作用？"></a>你是否了解 Quicklink、SW（Service Worker）对首屏加载的加速作用？</h2><h2 id="请你解释下-WebFlux-和传统-Spring-MVC-在线程模型和执行模型上的本质区别。为什么-WebFlux-更适合高并发场景？是否真的“性能一定更好”？请结合-Reactor-的-Mono-Flux-模型具体说明。"><a href="#请你解释下-WebFlux-和传统-Spring-MVC-在线程模型和执行模型上的本质区别。为什么-WebFlux-更适合高并发场景？是否真的“性能一定更好”？请结合-Reactor-的-Mono-Flux-模型具体说明。" class="headerlink" title="请你解释下 WebFlux 和传统 Spring MVC 在线程模型和执行模型上的本质区别。为什么 WebFlux 更适合高并发场景？是否真的“性能一定更好”？请结合 Reactor 的 Mono&#x2F;Flux 模型具体说明。"></a>请你解释下 WebFlux 和传统 Spring MVC 在线程模型和执行模型上的本质区别。为什么 WebFlux 更适合高并发场景？是否真的“性能一定更好”？请结合 Reactor 的 Mono&#x2F;Flux 模型具体说明。</h2><ul>
<li>首先对比一下MVC和WebFlux</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>Spring MVC（Servlet）</th>
<th>Spring WebFlux（Reactive）</th>
</tr>
</thead>
<tbody><tr>
<td>核心协议</td>
<td>Servlet API（Tomcat）</td>
<td>Reactive Streams（Netty）</td>
</tr>
<tr>
<td>IO 模型</td>
<td>阻塞 IO（BIO）</td>
<td>非阻塞 IO（NIO）</td>
</tr>
<tr>
<td>每请求线程</td>
<td>一个线程处理一个请求</td>
<td>少量线程处理大量请求</td>
</tr>
<tr>
<td>编程模型</td>
<td>命令式（Imperative）</td>
<td>响应式（Reactive）</td>
</tr>
<tr>
<td>线程数瓶颈</td>
<td>线程池耗尽&#x2F;阻塞等待</td>
<td>事件驱动、回调链、异步非阻塞</td>
</tr>
</tbody></table>
<blockquote>
<p>Webflux使用Reactor库的Mono（0-1个值）和Flux(0-N个值)作为基本抽象，支持链式组合和延迟执行</p>
</blockquote>
<ul>
<li><p>背压机制：</p>
<ul>
<li><p>是消费者主导的数据流拉取机制。简单说就是上有告诉下有，我现在只需要处理X个数据项，可以防止上游数据暴涨，处理延迟。</p>
</li>
<li><p>在Reactor中</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    .onBackpressureBuffer()</span><br><span class="line">    .subscribe(...);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>性能误区说明</p>
<ul>
<li><p>webflux并不是性能更优：</p>
<ul>
<li><p>对CPU密集型任务没有优势，比如视频转码</p>
</li>
<li><p>编程复杂度高，调试困难</p>
</li>
<li><p>如果依赖库本身是阻塞式的会拖慢整个响应链</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findById(id)  <span class="comment">// R2DBC 非阻塞查询</span></span><br><span class="line">        .map(user -&gt; &#123;</span><br><span class="line">            user.setName(user.getName().toUpperCase());</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比传统MVC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="line">public User getUser(@PathVariable Long id) &#123;</span><br><span class="line">    return jdbcUserRepo.findById(id); // 阻塞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="R2DBC-是如何实现非阻塞数据库访问的？它底层是如何避开-JDBC-的阻塞特性？使用时需要注意哪些兼容性问题？R2DBC-的事务是如何实现的？支持-ACID-吗？"><a href="#R2DBC-是如何实现非阻塞数据库访问的？它底层是如何避开-JDBC-的阻塞特性？使用时需要注意哪些兼容性问题？R2DBC-的事务是如何实现的？支持-ACID-吗？" class="headerlink" title="R2DBC 是如何实现非阻塞数据库访问的？它底层是如何避开 JDBC 的阻塞特性？使用时需要注意哪些兼容性问题？R2DBC 的事务是如何实现的？支持 ACID 吗？"></a>R2DBC 是如何实现非阻塞数据库访问的？它底层是如何避开 JDBC 的阻塞特性？使用时需要注意哪些兼容性问题？R2DBC 的事务是如何实现的？支持 ACID 吗？</h2><ul>
<li><p>R2DBC 是为了响应式编程设计的一种关系型数据库的非阻塞驱动标准，可以看作JDBC的异步版本，核心目标是为了解决JDBC是同步阻塞的，一条SQL执行完吓一跳才能进行下一条，无法容忍有WebFlux的非阻塞链路，就上提到的本身是阻塞式的会拖慢整个响应链</p>
</li>
<li><p>这不是一个对JDBC的封装而是一个全新的协议，完全绕开了JDBC，底层是Netty&#x2F;NIO编写的异步驱动</p>
</li>
<li><p>事件驱动：R2DBC是通过回调机制将数据库I&#x2F;O操作放入Reactor流中处理，返回的是Mono或者Flux</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;User&gt; user = dbClient.sql(<span class="string">&quot;SELECT * FROM user WHERE id = :id&quot;</span>)</span><br><span class="line">    .bind(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    .map(row -&gt; toUser(row))</span><br><span class="line">    .one();</span><br></pre></td></tr></table></figure>

<h2 id="ref-和-reactive-有什么本质区别？你在实际项目中是如何选择它们的？有没有哪些坑你踩过？"><a href="#ref-和-reactive-有什么本质区别？你在实际项目中是如何选择它们的？有没有哪些坑你踩过？" class="headerlink" title="ref 和 reactive 有什么本质区别？你在实际项目中是如何选择它们的？有没有哪些坑你踩过？"></a><code>ref</code> 和 <code>reactive</code> 有什么本质区别？你在实际项目中是如何选择它们的？有没有哪些坑你踩过？</h2><table>
<thead>
<tr>
<th>维度</th>
<th><code>ref</code></th>
<th><code>reactive</code></th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>将<strong>任意值（包括原始类型）</strong>变为响应式</td>
<td>将对象或数组转为响应式</td>
</tr>
<tr>
<td>包装形式</td>
<td>包装为 <code>&#123; value: xxx &#125;</code> 的对象</td>
<td>直接返回被 Proxy 包装的对象</td>
</tr>
<tr>
<td>访问方式</td>
<td>通过 <code>.value</code> 访问</td>
<td>直接访问属性</td>
</tr>
<tr>
<td>响应式原理</td>
<td>内部实现为 <code>reactive(&#123; value: xxx &#125;)</code></td>
<td>使用 Proxy 递归劫持对象属性</td>
</tr>
<tr>
<td>解构问题</td>
<td>解构会丢失响应性，需要 <code>toRefs()</code></td>
<td>解构同样会丢响应性，要 <code>toRefs()</code> 或 <code>toRaw()</code></td>
</tr>
<tr>
<td>使用场景</td>
<td>原始类型数据、响应式 DOM 引用等</td>
<td>表单对象、嵌套数据结构等</td>
</tr>
</tbody></table>
<ul>
<li><p>踩坑</p>
<ul>
<li>ref解构失效</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">ref</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Mike&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = user.<span class="property">value</span>  <span class="comment">// name 不再是响应式的</span></span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Mike&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = <span class="title function_">toRefs</span>(user)</span><br></pre></td></tr></table></figure>

<p>reactive:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>) <span class="comment">// newArr 是普通数组</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue3-的响应式系统是如何实现依赖收集与触发更新的？它相比-Vue2-的-Object-defineProperty-有哪些本质改进？你认为-Proxy-的缺点是什么？有没有无法拦截的操作？"><a href="#Vue3-的响应式系统是如何实现依赖收集与触发更新的？它相比-Vue2-的-Object-defineProperty-有哪些本质改进？你认为-Proxy-的缺点是什么？有没有无法拦截的操作？" class="headerlink" title="Vue3 的响应式系统是如何实现依赖收集与触发更新的？它相比 Vue2 的 Object.defineProperty 有哪些本质改进？你认为 Proxy 的缺点是什么？有没有无法拦截的操作？"></a>Vue3 的响应式系统是如何实现依赖收集与触发更新的？它相比 Vue2 的 Object.defineProperty 有哪些本质改进？你认为 Proxy 的缺点是什么？有没有无法拦截的操作？</h2><ul>
<li><p>vue3的响应式系统是由Proxy + Reflex + WeakMap实现的，目标是精准手机以来，按需触发，性能更优，功能更强</p>
</li>
<li><p>响应式系统的核心数据结构：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap: target -&gt; Map (key -&gt; Set(effect))</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br></pre></td></tr></table></figure>

<p>Vue3 在创建响应式对象时，会用 Proxy 包装对象，并在“读取属性”时收集依赖、“写入属性”时触发响应。</p>
<ul>
<li>收集依赖机制（读取时）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行该过程如下：</p>
<ol>
<li><p>执行 <code>obj.count</code> → 触发 Proxy 的 <code>get</code>。</p>
</li>
<li><p>内部调用 <code>track(target, key)</code>。</p>
</li>
<li><p>将当前副作用函数（effect）存入 <code>targetMap</code> 中对应的 key 下的 Set 中。</p>
</li>
</ol>
<ul>
<li>触发写入机制：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">count</span>++ <span class="comment">// 触发 Proxy 的 set</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用 <code>trigger(target, key)</code>。</p>
</li>
<li><p>从 <code>targetMap</code> 中找到 key 对应的所有副作用函数。</p>
</li>
<li><p>遍历调用，重新执行这些函数。</p>
</li>
</ol>
<ul>
<li>vue2的缺点：</li>
</ul>
<table>
<thead>
<tr>
<th>问题</th>
<th>Vue2</th>
</tr>
</thead>
<tbody><tr>
<td>新增&#x2F;删除属性</td>
<td>无法监听（需 <code>Vue.set()</code>）</td>
</tr>
<tr>
<td>数组下标</td>
<td>无法侦听 <code>arr[2] = xxx</code></td>
</tr>
<tr>
<td>深层嵌套对象</td>
<td>必须递归处理所有属性</td>
</tr>
<tr>
<td>性能</td>
<td>初始化递归对象属性开销大</td>
</tr>
<tr>
<td>原始类型</td>
<td>需包一层对象模拟</td>
</tr>
</tbody></table>
<ul>
<li>vue3的优势</li>
</ul>
<table>
<thead>
<tr>
<th>优点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>拦截所有操作</td>
<td>包括新增、删除属性、for in、has</td>
</tr>
<tr>
<td>动态代理</td>
<td>无需递归，按需代理</td>
</tr>
<tr>
<td>数组方法兼容好</td>
<td>能拦截 <code>push/pop/splice</code> 等</td>
</tr>
<tr>
<td>性能更优</td>
<td>延迟代理、按需追踪依赖</td>
</tr>
<tr>
<td>支持原始类型响应式（通过 <code>ref</code>）</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>Proxy的缺点</p>
<ul>
<li><p><strong>无法代理私有属性（#开头的）</strong></p>
</li>
<li><p><strong>无法代理基本类型（必须用 ref 包一层）</strong></p>
</li>
<li><p><strong>兼容性问题</strong>：不支持 IE11（也正因此 Vue3 放弃对 IE 的支持）</p>
</li>
</ul>
</li>
</ul>
<h2 id="如果你在-Vue3-中使用-reactive-创建了一个对象，对它执行-delete-操作会触发更新吗？为什么？Vue-是怎么拦截这个操作的？和-Reflect-deleteProperty-有什么关系？"><a href="#如果你在-Vue3-中使用-reactive-创建了一个对象，对它执行-delete-操作会触发更新吗？为什么？Vue-是怎么拦截这个操作的？和-Reflect-deleteProperty-有什么关系？" class="headerlink" title="如果你在 Vue3 中使用 reactive 创建了一个对象，对它执行 delete 操作会触发更新吗？为什么？Vue 是怎么拦截这个操作的？和 Reflect.deleteProperty() 有什么关系？"></a>如果你在 Vue3 中使用 <code>reactive</code> 创建了一个对象，对它执行 <code>delete</code> 操作会触发更新吗？为什么？Vue 是怎么拦截这个操作的？和 <code>Reflect.deleteProperty()</code> 有什么关系？</h2><ul>
<li><code>delete</code> 是可以触发响应式更新的（只要你是用 <code>reactive</code> 包裹过的对象）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Mike&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name is&#x27;</span>, state.<span class="property">name</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">name</span>  <span class="comment">// ✅ 触发更新，打印一次 undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>vue3的底层机制</p>
</li>
<li><p>Vue 在内部用 Proxy 拦截所有操作，其中包括：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">  <span class="keyword">if</span> (hadKey &amp;&amp; result) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, key, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Reflect.deleteProperty()</code> 是与 <code>delete obj.prop</code> 等效的方法，能确保语义一致，并返回删除是否成功的布尔值。</p>
</blockquote>
<h2 id="请你详细说说：Vue3-中的-shallowReactive、readonly-和-shallowReadonly-有什么区别？实际开发中你用过哪种？能举一个你用-shallowReactive-的业务场景吗？"><a href="#请你详细说说：Vue3-中的-shallowReactive、readonly-和-shallowReadonly-有什么区别？实际开发中你用过哪种？能举一个你用-shallowReactive-的业务场景吗？" class="headerlink" title="请你详细说说：Vue3 中的 shallowReactive、readonly 和 shallowReadonly 有什么区别？实际开发中你用过哪种？能举一个你用 shallowReactive 的业务场景吗？"></a>请你详细说说：Vue3 中的 <code>shallowReactive</code>、<code>readonly</code> 和 <code>shallowReadonly</code> 有什么区别？实际开发中你用过哪种？能举一个你用 <code>shallowReactive</code> 的业务场景吗？</h2><table>
<thead>
<tr>
<th>API</th>
<th>是否递归代理</th>
<th>是否可写</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>reactive</code></td>
<td>✅ 是</td>
<td>✅ 可写</td>
<td>默认对象响应式转换</td>
</tr>
<tr>
<td><code>readonly</code></td>
<td>✅ 是</td>
<td>❌ 不可写</td>
<td>提供只读状态（防止意外修改）</td>
</tr>
<tr>
<td><code>shallowReactive</code></td>
<td>❌ 否（只代理第一层）</td>
<td>✅ 可写</td>
<td>大型对象性能优化，或只对顶层感兴趣的场景</td>
</tr>
<tr>
<td><code>shallowReadonly</code></td>
<td>❌ 否</td>
<td>❌ 不可写</td>
<td>对 props 等只读数据浅保护</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Mike&#x27;</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">info</span>.<span class="property">age</span> = <span class="number">21</span>  <span class="comment">// ✅ 响应式更新</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浅响应</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">shallowReactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Mike&#x27;</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>       <span class="comment">// ✅ 响应式</span></span><br><span class="line">obj.<span class="property">info</span>.<span class="property">age</span> = <span class="number">21</span>       <span class="comment">// ❌ 不响应</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>readonly shallowReadonly</p>
<ul>
<li><p>防止组件或第三方库<strong>修改传入数据</strong>。</p>
</li>
<li><p>可以保护 <code>props</code>、全局配置、缓存值等。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title function_">readonly</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data.<span class="property">count</span> = <span class="number">1</span>  <span class="comment">// ❌ Vue 会报警告，不能修改只读对象</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue3-中你是如何组织大型应用的状态管理的？你是用-pinia-吗？pinia-的-store-是怎么支持响应式的？如何在-setup-中优雅地引入、拆分模块化-store？是否遇到过-SSR-或模块污染的问题？"><a href="#Vue3-中你是如何组织大型应用的状态管理的？你是用-pinia-吗？pinia-的-store-是怎么支持响应式的？如何在-setup-中优雅地引入、拆分模块化-store？是否遇到过-SSR-或模块污染的问题？" class="headerlink" title="Vue3 中你是如何组织大型应用的状态管理的？你是用 pinia 吗？pinia 的 store 是怎么支持响应式的？如何在 setup() 中优雅地引入、拆分模块化 store？是否遇到过 SSR 或模块污染的问题？"></a>Vue3 中你是如何组织大型应用的状态管理的？你是用 <code>pinia</code> 吗？pinia 的 store 是怎么支持响应式的？如何在 setup() 中优雅地引入、拆分模块化 store？是否遇到过 SSR 或模块污染的问题？</h2><ul>
<li><p>Pinia 是 Vue3 官方推荐的新一代状态管理库，<strong>相比 Vuex 更轻量、更组合式、更 TypeScript 友好</strong>。</p>
</li>
<li><p>piana的store本质上是一个reactive对象，其响应式机制主要是基于Vue3的响应式系统</p>
<ul>
<li><p><strong>state</strong>：使用 <code>reactive()</code> 包裹，使所有属性自动成为响应式</p>
</li>
<li><p><strong>getters</strong>：自动转换为计算属性 (computed)</p>
</li>
<li><p><strong>actions</strong>：普通函数，可直接修改 state</p>
</li>
</ul>
</li>
</ul>
<h2 id="Gzip的打包原理是什么？怎么配置的？"><a href="#Gzip的打包原理是什么？怎么配置的？" class="headerlink" title="Gzip的打包原理是什么？怎么配置的？"></a>Gzip的打包原理是什么？怎么配置的？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://github.com/xy-sea/blog/blob/main/markdown/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A982%25%E3%80%81%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E6%8F%90%E5%8D%8765%25.md" >blog&#x2F;markdown&#x2F;前端性能优化——包体积压缩82%、打包速度提升65%.md at main · xy-sea&#x2F;blog · GitHub<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="具体优化了多少？"><a href="#具体优化了多少？" class="headerlink" title="具体优化了多少？"></a>具体优化了多少？</h2><h2 id="怎么测试算法的性能？"><a href="#怎么测试算法的性能？" class="headerlink" title="怎么测试算法的性能？"></a>怎么测试算法的性能？</h2><h2 id="打包时执行npm-run-build发生了什么？"><a href="#打包时执行npm-run-build发生了什么？" class="headerlink" title="打包时执行npm run build发生了什么？"></a>打包时执行npm run build发生了什么？</h2><h2 id="讲讲你能想到的前端优化？"><a href="#讲讲你能想到的前端优化？" class="headerlink" title="讲讲你能想到的前端优化？"></a>讲讲你能想到的前端优化？</h2><h2 id="装饰器怎么使用的？为什么这么设计？"><a href="#装饰器怎么使用的？为什么这么设计？" class="headerlink" title="装饰器怎么使用的？为什么这么设计？"></a>装饰器怎么使用的？为什么这么设计？</h2><h2 id="二次封装的axios都有什么？为什么二次封装？"><a href="#二次封装的axios都有什么？为什么二次封装？" class="headerlink" title="二次封装的axios都有什么？为什么二次封装？"></a>二次封装的axios都有什么？为什么二次封装？</h2><h2 id="为什么使用-Ts-而不是-Js？"><a href="#为什么使用-Ts-而不是-Js？" class="headerlink" title="为什么使用 Ts 而不是 Js？"></a>为什么使用 Ts 而不是 Js？</h2><h2 id="大文件上传怎么设计的？（再看看源码）"><a href="#大文件上传怎么设计的？（再看看源码）" class="headerlink" title="大文件上传怎么设计的？（再看看源码）"></a>大文件上传怎么设计的？（再看看源码）</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/cpc980209/article/details/140093954" >大文件上传 :切片上传 + 断点续传 + 秒传 + 暂停上传<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/JavaScript/continue_to_upload.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" >面试官：大文件上传如何做断点续传？ | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="如何防止恶意上传超大文件或重复请求打爆服务器？"><a href="#如何防止恶意上传超大文件或重复请求打爆服务器？" class="headerlink" title="如何防止恶意上传超大文件或重复请求打爆服务器？"></a>如何防止恶意上传超大文件或重复请求打爆服务器？</h2><h2 id="了解前端性能优化？你说一下你能想到的前端优化都有什么？"><a href="#了解前端性能优化？你说一下你能想到的前端优化都有什么？" class="headerlink" title="了解前端性能优化？你说一下你能想到的前端优化都有什么？"></a>了解前端性能优化？你说一下你能想到的前端优化都有什么？</h2><h2 id="新雪花算法解决了什么问题？"><a href="#新雪花算法解决了什么问题？" class="headerlink" title="新雪花算法解决了什么问题？"></a>新雪花算法解决了什么问题？</h2><h2 id="说一下常见的web攻击？"><a href="#说一下常见的web攻击？" class="headerlink" title="说一下常见的web攻击？"></a>说一下常见的web攻击？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/JavaScript/security.html" >面试官：web常见的攻击方式有哪些？如何防御？ | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="浏览器渲染机制讲一下？"><a href="#浏览器渲染机制讲一下？" class="headerlink" title="浏览器渲染机制讲一下？"></a>浏览器渲染机制讲一下？</h2><h2 id="垃圾回收机制机制-？"><a href="#垃圾回收机制机制-？" class="headerlink" title="垃圾回收机制机制 ？"></a>垃圾回收机制机制 ？</h2><h2 id="JWT是什么？-美团"><a href="#JWT是什么？-美团" class="headerlink" title="JWT是什么？(美团)"></a>JWT是什么？(美团)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTComponent</span> &#123;</span><br><span class="line">    <span class="comment">// 私钥</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;my.secretkey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretkey;</span><br><span class="line">    <span class="keyword">private</span> Algorithm algorithm;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        algorithm = Algorithm.HMAC256(secretkey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now().plusMonths(<span class="number">1</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> JWT.create()</span><br><span class="line">                .withPayload(map)</span><br><span class="line">                .withIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .withExpiresAt(Date.from(time.atZone(ZoneId.systemDefault()).toInstant()))</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">        <span class="keyword">return</span> encodePos(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;DecodedJWT&gt; <span class="title function_">decode</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> JWT.require(algorithm).build().verify(decodePos(token));</span><br><span class="line">            <span class="keyword">return</span> Mono.just(decodedJWT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException | SignatureVerificationException | JWTDecodeException e) &#123;</span><br><span class="line">            <span class="type">Code</span> <span class="variable">code</span> <span class="operator">=</span> Code.FORBIDDEN;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TokenExpiredException) &#123;</span><br><span class="line">                code = Code.TOKEN_EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Mono.error(XException.builder().code(code).build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">POS</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">encodePos</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).insert(POS, <span class="string">&quot;W&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">decodePos</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).deleteCharAt(POS).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON Web Token（JWT）是一种开放标准（RFC 7519），用于在各方之间安全地传输信息。它以紧凑且自包含的方式，通过 JSON 对象传递经过数字签名或加密的声明（claims）。以下是关于 JWT 的详细说明：</p>
<hr>
<h3 id="1-JWT-结构"><a href="#1-JWT-结构" class="headerlink" title="1. JWT 结构"></a><strong>1. JWT 结构</strong></h3><p>JWT 由三部分组成，用 <code>.</code> 分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<h4 id="1-1-Header（头部）"><a href="#1-1-Header（头部）" class="headerlink" title="1.1 Header（头部）"></a><strong>1.1 Header（头部）</strong></h4><ul>
<li><p>包含令牌类型（<code>typ</code>，固定为<code>JWT</code>）和签名算法（<code>alg</code>，如<code>HS256</code>或<code>RSA</code>）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>会被 Base64URL 编码。</p>
</li>
</ul>
<h4 id="1-2-Payload（负载）"><a href="#1-2-Payload（负载）" class="headerlink" title="1.2 Payload（负载）"></a><strong>1.2 Payload（负载）</strong></h4><ul>
<li><p>存放实际数据，称为 <strong>声明（claims）</strong>，分为三类：</p>
<ul>
<li><strong>预定义声明</strong>（非强制）：如 <code>exp</code>（过期时间）、<code>iat</code>（签发时间）、<code>iss</code>（签发者）。</li>
<li><strong>公共声明</strong>：可自定义，需避免与已注册声明冲突。</li>
<li><strong>私有声明</strong>：双方约定的自定义数据。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同样会被 Base64URL 编码。</p>
</li>
</ul>
<h4 id="1-3-Signature（签名）"><a href="#1-3-Signature（签名）" class="headerlink" title="1.3 Signature（签名）"></a><strong>1.3 Signature（签名）</strong></h4><ul>
<li><p>用于验证令牌的完整性和来源合法性。</p>
</li>
<li><p>生成方式：将编码后的 Header 和 Payload 用 <code>.</code> 连接，再通过 Header 中指定的算法（如 <code>HS256</code>）和密钥进行签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),</span><br><span class="line">  secret_key</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-JWT-的核心作用"><a href="#2-JWT-的核心作用" class="headerlink" title="2. JWT 的核心作用"></a><strong>2. JWT 的核心作用</strong></h3><ul>
<li><strong>身份认证</strong>：用户登录后，服务器生成 JWT 返回给客户端。客户端后续请求携带此 Token，服务器验证其有效性。</li>
<li><strong>安全传输信息</strong>：由于签名保护，信息可被验证且防篡改，适合传输非敏感数据。</li>
</ul>
<hr>
<h3 id="3-JWT-的优势"><a href="#3-JWT-的优势" class="headerlink" title="3. JWT 的优势"></a><strong>3. JWT 的优势</strong></h3><ul>
<li><strong>无状态</strong>：服务器无需存储会话信息（如 Session），适合分布式系统。</li>
<li><strong>跨域支持</strong>：可通过 URL、POST 参数或 HTTP Header 发送，轻松实现跨域身份验证（如单点登录 SSO）。</li>
<li><strong>自包含性</strong>：所有必要信息（如用户 ID、权限）可直接嵌入 Token，减少数据库查询。</li>
</ul>
<hr>
<h3 id="4-典型使用场景"><a href="#4-典型使用场景" class="headerlink" title="4. 典型使用场景"></a><strong>4. 典型使用场景</strong></h3><ol>
<li><strong>用户认证</strong>：客户端登录后获取 JWT，后续请求在 <code>Authorization</code> Header 中携带 <code>Bearer &lt;Token&gt;</code>。</li>
<li><strong>API 安全</strong>：服务间 API 调用通过 JWT 验证身份。</li>
<li><strong>单点登录（SSO）</strong>：用户登录一次后，多个关联系统共享同一 Token。</li>
</ol>
<hr>
<h3 id="5-安全注意事项"><a href="#5-安全注意事项" class="headerlink" title="5. 安全注意事项"></a><strong>5. 安全注意事项</strong></h3><ul>
<li><strong>敏感数据</strong>：Payload 仅经过 Base64 编码，未加密，避免存储密码等敏感信息。</li>
<li><strong>密钥保护</strong>：签名密钥泄露会导致攻击者伪造 Token，需严格保密。</li>
<li><strong>HTTPS</strong>：必须通过 HTTPS 传输，防止 Token 被截获。</li>
<li><strong>短有效期</strong>：设置较短的过期时间（<code>exp</code>），减少泄露后的风险。</li>
<li><strong>注销机制</strong>：JWT 无法直接失效，需借助黑名单、短期 Token 或客户端主动删除。</li>
</ul>
<hr>
<h3 id="6-与-Session-的对比"><a href="#6-与-Session-的对比" class="headerlink" title="6. 与 Session 的对比"></a><strong>6. 与 Session 的对比</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>JWT</strong></th>
<th><strong>Session</strong></th>
</tr>
</thead>
<tbody><tr>
<td>状态管理</td>
<td>无状态</td>
<td>服务器端存储会话数据</td>
</tr>
<tr>
<td>扩展性</td>
<td>适合分布式系统</td>
<td>需共享 Session 存储（如 Redis）</td>
</tr>
<tr>
<td>安全性</td>
<td>依赖密钥和 HTTPS</td>
<td>依赖 Cookie 安全标志（Secure&#x2F;HttpOnly）</td>
</tr>
<tr>
<td>性能</td>
<td>减少数据库查询</td>
<td>每次请求需验证 Session 有效性</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-代码示例（Node-js）"><a href="#7-代码示例（Node-js）" class="headerlink" title="7. 代码示例（Node.js）"></a><strong>7. 代码示例（Node.js）</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 JWT</span></span><br><span class="line"><span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(</span><br><span class="line">  &#123; <span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span>, <span class="attr">role</span>: <span class="string">&#x27;admin&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;your-secret-key&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">expiresIn</span>: <span class="string">&#x27;1h&#x27;</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 JWT</span></span><br><span class="line">jwt.<span class="title function_">verify</span>(token, <span class="string">&#x27;your-secret-key&#x27;</span>, <span class="function">(<span class="params">err, decoded</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Invalid Token&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(decoded); <span class="comment">// &#123; userId: &#x27;123&#x27;, role: &#x27;admin&#x27;, iat: ..., exp: ... &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>通过以上机制，JWT 成为现代 Web 开发中身份验证和信息交换的重要工具，但在使用时需严格遵循安全实践。</p>
<h2 id="Vite和Webpack有什么区别？"><a href="#Vite和Webpack有什么区别？" class="headerlink" title="Vite和Webpack有什么区别？"></a>Vite和Webpack有什么区别？</h2><h2 id="水平鉴权垂直鉴权是怎么做的？"><a href="#水平鉴权垂直鉴权是怎么做的？" class="headerlink" title="水平鉴权垂直鉴权是怎么做的？"></a>水平鉴权垂直鉴权是怎么做的？</h2><h2 id="加密算法用的哪个？为什么使用这个？"><a href="#加密算法用的哪个？为什么使用这个？" class="headerlink" title="加密算法用的哪个？为什么使用这个？"></a>加密算法用的哪个？为什么使用这个？</h2><h2 id="为什么采用mysql和nosql结合的方式"><a href="#为什么采用mysql和nosql结合的方式" class="headerlink" title="为什么采用mysql和nosql结合的方式"></a>为什么采用mysql和nosql结合的方式</h2><h2 id="数据库优化上都做了些什么"><a href="#数据库优化上都做了些什么" class="headerlink" title="数据库优化上都做了些什么"></a>数据库优化上都做了些什么</h2><h2 id="为什么动态import导入能提升首屏加载性能"><a href="#为什么动态import导入能提升首屏加载性能" class="headerlink" title="为什么动态import导入能提升首屏加载性能"></a>为什么动态import导入能提升首屏加载性能</h2><h2 id="前端性能测试都有什么怎么做的？怎么优化？"><a href="#前端性能测试都有什么怎么做的？怎么优化？" class="headerlink" title="前端性能测试都有什么怎么做的？怎么优化？"></a>前端性能测试都有什么怎么做的？怎么优化？</h2><h2 id="前端缓存讲一下"><a href="#前端缓存讲一下" class="headerlink" title="前端缓存讲一下"></a>前端缓存讲一下</h2><h2 id="什么是前端AST语法树？有什么应用？"><a href="#什么是前端AST语法树？有什么应用？" class="headerlink" title="什么是前端AST语法树？有什么应用？"></a>什么是前端AST语法树？有什么应用？</h2><p>前端开发中的 <strong>AST（Abstract Syntax Tree，抽象语法树）</strong> 是代码的抽象语法结构的树状表示。它是编译原理中的核心概念，广泛应用于代码转换、静态分析、代码优化等场景（如 Babel、ESLint、Webpack 等工具）。</p>
<hr>
<h3 id="1-AST-是什么？"><a href="#1-AST-是什么？" class="headerlink" title="1. AST 是什么？"></a><strong>1. AST 是什么？</strong></h3><ul>
<li><p><strong>定义</strong>：AST 是源代码的树形表示，忽略语法细节（如括号、分号），只关注代码的逻辑结构。</p>
</li>
<li><p><strong>作用</strong>：将代码转换为机器可操作的结构，方便进行代码分析、转换、优化。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码：const sum = (a, b) =&gt; a + b;</span></span><br><span class="line"><span class="comment">// 对应的 AST 结构（简化版）：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="attr">body</span>: [&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">    <span class="attr">declarations</span>: [&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">      <span class="attr">id</span>: &#123; <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;sum&quot;</span> &#125;,</span><br><span class="line">      <span class="attr">init</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;ArrowFunctionExpression&quot;</span>,</span><br><span class="line">        <span class="attr">params</span>: [</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;a&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;b&quot;</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">body</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;BinaryExpression&quot;</span>,</span><br><span class="line">          <span class="attr">operator</span>: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">          <span class="attr">left</span>: &#123; <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;a&quot;</span> &#125;,</span><br><span class="line">          <span class="attr">right</span>: &#123; <span class="attr">type</span>: <span class="string">&quot;Identifier&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;b&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-AST-的生成过程"><a href="#2-AST-的生成过程" class="headerlink" title="2. AST 的生成过程"></a><strong>2. AST 的生成过程</strong></h3><p>AST 的生成分为两个阶段：</p>
<ol>
<li><p><strong>词法分析（Lexical Analysis）</strong>：</p>
<ul>
<li>将代码字符串拆分为 <strong>Token 流</strong>（如关键字、标识符、运算符等）。</li>
<li>例如：<code>const sum = 42;</code> 会被拆分为 <code>[const, sum, =, 42, ;]</code>。</li>
</ul>
</li>
<li><p><strong>语法分析（Syntax Analysis）</strong>：</p>
<ul>
<li>根据语法规则（如 ECMAScript 规范）将 Token 流转换为 AST。</li>
<li>使用 <strong>递归下降（Recursive Descent）</strong> 或 <strong>LR 解析器</strong> 等算法构建树结构。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-AST-的核心结构"><a href="#3-AST-的核心结构" class="headerlink" title="3. AST 的核心结构"></a><strong>3. AST 的核心结构</strong></h3><p>AST 的节点类型由 <a class="link"   target="_blank" rel="noopener" href="https://github.com/estree/estree" >ESTree 规范<i class="fas fa-external-link-alt"></i></a> 定义，常见节点类型：</p>
<ul>
<li><strong>Program</strong>：根节点，表示整个程序。</li>
<li><strong>VariableDeclaration</strong>：变量声明（如 <code>let</code>, <code>const</code>）。</li>
<li><strong>FunctionDeclaration</strong>：函数声明。</li>
<li><strong>ExpressionStatement</strong>：表达式语句（如 <code>a + b;</code>）。</li>
<li><strong>CallExpression</strong>：函数调用（如 <code>fn()</code>）。</li>
<li><strong>MemberExpression</strong>：成员表达式（如 <code>obj.property</code>）。</li>
</ul>
<hr>
<h3 id="4-AST-在前端的应用"><a href="#4-AST-在前端的应用" class="headerlink" title="4. AST 在前端的应用"></a><strong>4. AST 在前端的应用</strong></h3><h4 id="1-代码转换（Babel）"><a href="#1-代码转换（Babel）" class="headerlink" title="(1) 代码转换（Babel）"></a><strong>(1) 代码转换（Babel）</strong></h4><ul>
<li><p><strong>流程</strong>：源码 → AST → 修改 AST → 生成新代码。</p>
</li>
<li><p><strong>示例</strong>：将 ES6+ 代码转换为 ES5。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Babel 插件示例：转换箭头函数</span></span><br><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  <span class="title class_">ArrowFunctionExpression</span>(path) &#123;</span><br><span class="line">    path.<span class="title function_">replaceWith</span>(</span><br><span class="line">      t.<span class="title function_">functionExpression</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        path.<span class="property">node</span>.<span class="property">params</span>,</span><br><span class="line">        t.<span class="title function_">blockStatement</span>([t.<span class="title function_">returnStatement</span>(path.<span class="property">node</span>.<span class="property">body</span>)])</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-静态代码分析（ESLint）"><a href="#2-静态代码分析（ESLint）" class="headerlink" title="(2) 静态代码分析（ESLint）"></a><strong>(2) 静态代码分析（ESLint）</strong></h4><ul>
<li><p>通过遍历 AST 检查代码风格、潜在错误。</p>
</li>
<li><p><strong>示例</strong>：检测未使用的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ESLint 规则核心逻辑</span></span><br><span class="line">context.<span class="title function_">report</span>(&#123;</span><br><span class="line">  <span class="attr">node</span>: variableNode,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&quot;变量未使用！&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-代码打包与优化（Webpack）"><a href="#3-代码打包与优化（Webpack）" class="headerlink" title="(3) 代码打包与优化（Webpack）"></a><strong>(3) 代码打包与优化（Webpack）</strong></h4><ul>
<li>依赖分析：通过 AST 分析模块间的依赖关系。</li>
<li>Tree Shaking：标记未使用的代码并删除。</li>
</ul>
<hr>
<h3 id="5-如何操作-AST？"><a href="#5-如何操作-AST？" class="headerlink" title="5. 如何操作 AST？"></a><strong>5. 如何操作 AST？</strong></h3><p>常用工具库：</p>
<ul>
<li><strong>解析器（Parser）</strong>：<ul>
<li><code>@babel/parser</code>：将 JavaScript 代码解析为 AST。</li>
<li><code>acorn</code>：轻量级 JavaScript 解析器。</li>
</ul>
</li>
<li><strong>遍历器（Traverser）</strong>：<ul>
<li><code>@babel/traverse</code>：遍历并修改 AST。</li>
</ul>
</li>
<li><strong>生成器（Generator）</strong>：<ul>
<li><code>@babel/generator</code>：将 AST 转换为代码。</li>
</ul>
</li>
</ul>
<h4 id="示例：修改代码中的变量名"><a href="#示例：修改代码中的变量名" class="headerlink" title="示例：修改代码中的变量名"></a><strong>示例：修改代码中的变量名</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`let hello = &#x27;world&#x27;;`</span>;</span><br><span class="line"><span class="keyword">const</span> ast = parser.<span class="title function_">parse</span>(code, &#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === <span class="string">&#x27;hello&#x27;</span>) &#123;</span><br><span class="line">      path.<span class="property">node</span>.<span class="property">name</span> = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// 修改变量名</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = <span class="title function_">generator</span>(ast).<span class="property">code</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// 输出：let hi = &#x27;world&#x27;;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-AST-可视化工具"><a href="#6-AST-可视化工具" class="headerlink" title="6. AST 可视化工具"></a><strong>6. AST 可视化工具</strong></h3><ul>
<li><strong>AST Explorer</strong>：<a class="link"   target="_blank" rel="noopener" href="https://astexplorer.net/" >https://astexplorer.net/<i class="fas fa-external-link-alt"></i></a><ul>
<li>支持多种语言（JavaScript、CSS、HTML），实时查看代码对应的 AST。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-深入理解-AST"><a href="#7-深入理解-AST" class="headerlink" title="7. 深入理解 AST"></a><strong>7. 深入理解 AST</strong></h3><ul>
<li><strong>与 DOM 树的区别</strong>：AST 描述代码逻辑结构，DOM 树描述 HTML&#x2F;XML 的文档结构。</li>
<li><strong>性能优化</strong>：AST 操作可能涉及大规模遍历，需注意算法复杂度。</li>
<li><strong>自定义工具</strong>：通过操作 AST 可实现代码生成器、自定义语法扩展等。</li>
</ul>
<h2 id="深拷贝浅拷贝讲一下"><a href="#深拷贝浅拷贝讲一下" class="headerlink" title="深拷贝浅拷贝讲一下"></a>深拷贝浅拷贝讲一下</h2><h2 id="讲一讲前端事件循环机制"><a href="#讲一讲前端事件循环机制" class="headerlink" title="讲一讲前端事件循环机制"></a>讲一讲前端事件循环机制</h2><h2 id="你的数据库怎么设计的？-为什么这么设计？"><a href="#你的数据库怎么设计的？-为什么这么设计？" class="headerlink" title="你的数据库怎么设计的？ 为什么这么设计？"></a>你的数据库怎么设计的？ 为什么这么设计？</h2><h2 id="IndexedDB讲一下"><a href="#IndexedDB讲一下" class="headerlink" title="IndexedDB讲一下"></a>IndexedDB讲一下</h2><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/2503_90377662/article/details/147903074?spm=1001.2014.3001.5502" >IndexedDB详解-CSDN博客<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="CI-CD全流程讲一下"><a href="#CI-CD全流程讲一下" class="headerlink" title="CI&#x2F;CD全流程讲一下"></a>CI&#x2F;CD全流程讲一下</h2><h2 id="怎么基于命令行创建一个空分支在github"><a href="#怎么基于命令行创建一个空分支在github" class="headerlink" title="怎么基于命令行创建一个空分支在github"></a>怎么基于命令行创建一个空分支在github</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit --allow-empty -m <span class="string">&quot;Initial empty commit&quot;</span></span><br><span class="line">git remote add origin https://github.com/username/repository.git</span><br><span class="line">git push origin master:empty-branch</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用ts-和js有什么区别？"><a href="#为什么使用ts-和js有什么区别？" class="headerlink" title="为什么使用ts?和js有什么区别？"></a>为什么使用ts?和js有什么区别？</h2><h2 id="讲一讲你的项目上的亮点吧-你自己觉得比较有说法的点"><a href="#讲一讲你的项目上的亮点吧-你自己觉得比较有说法的点" class="headerlink" title="讲一讲你的项目上的亮点吧 你自己觉得比较有说法的点"></a>讲一讲你的项目上的亮点吧 你自己觉得比较有说法的点</h2><h2 id="讲一讲HTML5-CSS3，ES5-6新特性"><a href="#讲一讲HTML5-CSS3，ES5-6新特性" class="headerlink" title="讲一讲HTML5,CSS3，ES5&#x2F;6新特性"></a>讲一讲HTML5,CSS3，ES5&#x2F;6新特性</h2><h2 id="VUEX和Piana有什么区别？"><a href="#VUEX和Piana有什么区别？" class="headerlink" title="VUEX和Piana有什么区别？"></a>VUEX和Piana有什么区别？</h2><h2 id="讲讲HTTP协议？"><a href="#讲讲HTTP协议？" class="headerlink" title="讲讲HTTP协议？"></a>讲讲HTTP协议？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/HTTP_HTTPS.html" >面试官：什么是HTTP? HTTP 和 HTTPS 的区别? | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="输入url到显示页面都发生了什么？"><a href="#输入url到显示页面都发生了什么？" class="headerlink" title="输入url到显示页面都发生了什么？"></a>输入url到显示页面都发生了什么？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/after_url.html" >面试官：说说地址栏输入 URL 敲下回车后发生了什么? | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="JS的事件循环机制"><a href="#JS的事件循环机制" class="headerlink" title="JS的事件循环机制"></a>JS的事件循环机制</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/JavaScript/event_loop.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" >面试官：说说你对事件循环的理解 | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="为什么要有虚拟DOM"><a href="#为什么要有虚拟DOM" class="headerlink" title="为什么要有虚拟DOM"></a>为什么要有虚拟DOM</h2><h2 id="Diff算法讲一下"><a href="#Diff算法讲一下" class="headerlink" title="Diff算法讲一下"></a>Diff算法讲一下</h2><h2 id="flex和grid"><a href="#flex和grid" class="headerlink" title="flex和grid"></a>flex和grid</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/css/flexbox.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" >面试官：说说flexbox（弹性盒布局模型）,以及适用场景？ | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/UDP_TCP.html#%E4%B8%80%E3%80%81udp" >面试官：如何理解UDP 和 TCP? 区别? 应用场景? | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="css-属性说一下"><a href="#css-属性说一下" class="headerlink" title="css 属性说一下"></a>css 属性说一下</h2><h2 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h2><h2 id="null-和undefined的区别"><a href="#null-和undefined的区别" class="headerlink" title="null 和undefined的区别"></a>null 和undefined的区别</h2><p>在 JavaScript 中，<code>null</code> 和 <code>undefined</code> 都表示“无”或“空值”，但它们在语义、用途和行为上有明显区别。以下是详细的对比和解释：</p>
<hr>
<h3 id="1-定义与类型"><a href="#1-定义与类型" class="headerlink" title="1. 定义与类型"></a><strong>1. 定义与类型</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>undefined</code></th>
<th><code>null</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td><code>typeof undefined</code> 返回 <code>&quot;undefined&quot;</code></td>
<td><code>typeof null</code> 返回 <code>&quot;object&quot;</code>（历史遗留问题）</td>
</tr>
<tr>
<td><strong>含义</strong></td>
<td>表示变量已声明但未赋值或未初始化。</td>
<td>表示一个<strong>明确的空值</strong>，通常由开发者显式赋值。</td>
</tr>
<tr>
<td><strong>默认行为</strong></td>
<td>函数未返回值时默认返回 <code>undefined</code>。</td>
<td>需手动赋值（如 <code>let x = null;</code>）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-常见场景"><a href="#2-常见场景" class="headerlink" title="2. 常见场景"></a><strong>2. 常见场景</strong></h3><h4 id="undefined-的场景"><a href="#undefined-的场景" class="headerlink" title="undefined 的场景"></a><strong><code>undefined</code> 的场景</strong></h4><ol>
<li><p>变量声明但未赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象属性不存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title function_">console</span>(obj.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数未传参：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x); &#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数无返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="null-的场景"><a href="#null-的场景" class="headerlink" title="null 的场景"></a><strong><code>null</code> 的场景</strong></h4><ol>
<li><p><strong>显式清空变量或对象引用</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="title function_">fetchData</span>(); <span class="comment">// 假设返回一个对象</span></span><br><span class="line">data = <span class="literal">null</span>; <span class="comment">// 释放引用，帮助垃圾回收</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表示“无”的语义化值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">address</span>: <span class="literal">null</span> &#125;; <span class="comment">// 用户无地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>API 返回空值</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;non-existent-id&quot;</span>); <span class="comment">// 返回 null</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-关键区别"><a href="#3-关键区别" class="headerlink" title="3. 关键区别"></a><strong>3. 关键区别</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><code>undefined</code></th>
<th><code>null</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>赋值意图</strong></td>
<td>表示未初始化或缺失值（系统默认行为）。</td>
<td>表示开发者主动赋予的空值。</td>
</tr>
<tr>
<td><strong>类型检查</strong></td>
<td><code>undefined</code> 是独立类型。</td>
<td><code>null</code> 被错误标记为 <code>&quot;object&quot;</code>。</td>
</tr>
<tr>
<td><strong>严格相等比较</strong></td>
<td><code>undefined === undefined</code> → <code>true</code></td>
<td><code>null === null</code> → <code>true</code></td>
</tr>
<tr>
<td><strong>宽松相等比较</strong></td>
<td><code>null == undefined</code> → <code>true</code></td>
<td>但 <code>null</code> 与其他值宽松相等会返回 <code>false</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a><strong>4. 注意事项</strong></h3><ol>
<li><p><strong>隐式转换问题</strong>：</p>
<ul>
<li><p>使用 <code>==</code> 时，<code>null</code> 和 <code>undefined</code> 会被认为相等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但使用 <code>===</code> 时，它们不相等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>安全检查方法</strong>：</p>
<ul>
<li><p>检查 <code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> variable === <span class="string">&quot;undefined&quot;</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 <code>null</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (variable === <span class="literal">null</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JSON 序列化</strong>：</p>
<ul>
<li><p><code>undefined</code> 会被 JSON 忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="literal">undefined</span>, <span class="attr">b</span>: <span class="literal">null</span> &#125;); <span class="comment">// &#x27;&#123;&quot;b&quot;:null&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>null</code> 会被保留。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-使用建议"><a href="#5-使用建议" class="headerlink" title="5. 使用建议"></a><strong>5. 使用建议</strong></h3><ol>
<li>**优先使用 <code>undefined</code>**：<ul>
<li>让系统自动处理未初始化或缺失的值（如函数默认参数）。</li>
</ul>
</li>
<li>**显式使用 <code>null</code>**：<ul>
<li>当需要明确表示“无”或“空对象引用”时（如清空对象引用）。</li>
</ul>
</li>
<li><strong>避免混用</strong>：<ul>
<li>在代码中保持一致性（例如，统一用 <code>null</code> 表示空值，或用 <code>undefined</code> 表示缺失）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><ul>
<li><code>undefined</code> 是 JavaScript 的默认空值，表示“未定义”。</li>
<li><code>null</code> 是开发者主动赋予的空值，表示“无对象”。</li>
<li>理解它们的区别可以避免逻辑错误，写出更清晰的代码。</li>
</ul>
<h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><p>在 HTTP 协议中，<strong>Keep-Alive</strong> 是一种通过复用 TCP 连接来减少频繁建立和关闭连接开销的机制。它可以显著提升性能，尤其是在需要多次请求资源的场景（如网页加载）。以下是 <strong>Keep-Alive 的实现原理</strong>和 <strong>手动实现示例</strong>：</p>
<hr>
<h3 id="一、Keep-Alive-的核心原理"><a href="#一、Keep-Alive-的核心原理" class="headerlink" title="一、Keep-Alive 的核心原理"></a>一、Keep-Alive 的核心原理</h3><ol>
<li><p><strong>单连接复用</strong><br>默认情况下，HTTP&#x2F;1.1 会启用持久连接（Persistent Connection），即一个 TCP 连接可以处理多个 HTTP 请求和响应，无需为每个请求重新建立连接。</p>
</li>
<li><p><strong>关键 HTTP 头部</strong></p>
<ul>
<li><code>Connection: keep-alive</code>：客户端&#x2F;服务端表明支持 Keep-Alive。</li>
<li><code>Keep-Alive: timeout=5, max=100</code>：服务端可指定连接保持时间（秒）和最大请求数。</li>
</ul>
</li>
<li><p><strong>连接生命周期管理</strong></p>
<ul>
<li><strong>超时关闭</strong>：如果连接空闲超过 <code>timeout</code>，自动关闭。</li>
<li><strong>最大请求数</strong>：处理完 <code>max</code> 个请求后关闭连接。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、实现一个简单的-Keep-Alive-服务器（Node-js-示例）"><a href="#二、实现一个简单的-Keep-Alive-服务器（Node-js-示例）" class="headerlink" title="二、实现一个简单的 Keep-Alive 服务器（Node.js 示例）"></a>二、实现一个简单的 Keep-Alive 服务器（Node.js 示例）</h3><h4 id="1-使用原生-http-模块"><a href="#1-使用原生-http-模块" class="headerlink" title="1. 使用原生 http 模块"></a>1. 使用原生 <code>http</code> 模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建支持 Keep-Alive 的服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置 Keep-Alive 响应头（HTTP/1.1 默认开启，此处仅为演示）</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Connection&#x27;</span>, <span class="string">&#x27;keep-alive&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Keep-Alive&#x27;</span>, <span class="string">&#x27;timeout=10, max=5&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理请求</span></span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello, Keep-Alive!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器层级的 Keep-Alive 超时（Node.js 默认 5 秒）</span></span><br><span class="line">server.<span class="property">keepAliveTimeout</span> = <span class="number">10</span> * <span class="number">1000</span>; <span class="comment">// 10 秒</span></span><br></pre></td></tr></table></figure>

<h4 id="2-关键代码解释"><a href="#2-关键代码解释" class="headerlink" title="2. 关键代码解释"></a>2. 关键代码解释</h4><ul>
<li><strong>设置响应头</strong>：显式声明 <code>Connection: keep-alive</code> 和 <code>Keep-Alive</code> 参数（可选）。</li>
<li><strong>全局超时配置</strong>：通过 <code>server.keepAliveTimeout</code> 设置空闲连接超时时间。</li>
<li><strong>请求计数管理</strong>：需自行记录每个连接的请求次数，达到 <code>max</code> 后关闭（此处未实现，需扩展）。</li>
</ul>
<hr>
<h3 id="三、高级实现：跟踪连接请求次数"><a href="#三、高级实现：跟踪连接请求次数" class="headerlink" title="三、高级实现：跟踪连接请求次数"></a>三、高级实现：跟踪连接请求次数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前连接的 Socket</span></span><br><span class="line">  <span class="keyword">const</span> socket = req.<span class="property">socket</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录请求次数</span></span><br><span class="line">  socket.<span class="property">requestCount</span> = (socket.<span class="property">requestCount</span> || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 Keep-Alive 头部</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Connection&#x27;</span>, <span class="string">&#x27;keep-alive&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Keep-Alive&#x27;</span>, <span class="string">`timeout=10, max=5`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理请求</span></span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">`Request count: <span class="subst">$&#123;socket.requestCount&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超过最大请求数后关闭连接</span></span><br><span class="line">  <span class="keyword">if</span> (socket.<span class="property">requestCount</span> &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">    socket.<span class="title function_">destroy</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="property">keepAliveTimeout</span> = <span class="number">10000</span>; <span class="comment">// 10 秒超时</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、Keep-Alive-的注意事项"><a href="#四、Keep-Alive-的注意事项" class="headerlink" title="四、Keep-Alive 的注意事项"></a>四、Keep-Alive 的注意事项</h3><ol>
<li><p><strong>客户端兼容性</strong><br>大多数现代浏览器默认支持 Keep-Alive，但需确保客户端未显式关闭（如请求头含 <code>Connection: close</code>）。</p>
</li>
<li><p><strong>资源管理</strong></p>
<ul>
<li><strong>超时设置</strong>：避免空闲连接长期占用资源。</li>
<li><strong>最大请求数</strong>：防止单个连接处理过多请求导致不公平调度。</li>
</ul>
</li>
<li><p><strong>与 HTTP&#x2F;2 的区别</strong><br>HTTP&#x2F;2 采用多路复用（Multiplexing），天然支持更高效的连接复用，无需依赖 Keep-Alive 机制。</p>
</li>
</ol>
<hr>
<h3 id="五、测试-Keep-Alive-是否生效"><a href="#五、测试-Keep-Alive-是否生效" class="headerlink" title="五、测试 Keep-Alive 是否生效"></a>五、测试 Keep-Alive 是否生效</h3><p>使用 <code>curl</code> 命令测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送请求并查看响应头</span></span><br><span class="line">curl -v http://localhost:3000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看连接复用情况（观察端口是否变化）</span></span><br><span class="line">curl http://localhost:3000</span><br><span class="line">curl http://localhost:3000</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ul>
<li><strong>Keep-Alive 本质</strong>：通过复用 TCP 连接减少握手开销，提升性能。</li>
<li><strong>实现核心</strong>：服务端设置正确的头部，并管理连接的生命周期（超时和最大请求数）。</li>
<li><strong>现代实践</strong>：HTTP&#x2F;1.1 默认开启 Keep-Alive，而 HTTP&#x2F;2 更进一步优化了连接复用机制。</li>
</ul>
<h2 id="最近在学什么？"><a href="#最近在学什么？" class="headerlink" title="最近在学什么？"></a>最近在学什么？</h2><ul>
<li>最近在学index-db实现刷新保留大文件上传的状态</li>
</ul>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/JavaScript/this.html" >面试官：谈谈this对象的理解 | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="nexttick"><a href="#nexttick" class="headerlink" title="nexttick"></a>nexttick</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue/nexttick.html" >面试官：Vue中的$nextTick有什么作用？ | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="如何理解OSI七层模型？"><a href="#如何理解OSI七层模型？" class="headerlink" title="如何理解OSI七层模型？"></a>如何理解OSI七层模型？</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://vue3js.cn/interview/http/OSI.html#%E4%BA%8C%E3%80%81%E5%88%92%E5%88%86" >面试官：如何理解OSI七层模型? | web前端面试 - 面试官系列<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="你对大模型有什么看法？"><a href="#你对大模型有什么看法？" class="headerlink" title="你对大模型有什么看法？"></a>你对大模型有什么看法？</h2><ul>
<li><p>大模型（如GPT-4、PaLM、BERT等）作为人工智能领域的重要突破，正在深刻改变技术、商业和社会。以下是我对其的看法，涵盖技术优势、挑战、应用场景及未来展望：</p>
<hr>
<h3 id="一、技术优势"><a href="#一、技术优势" class="headerlink" title="一、技术优势"></a><strong>一、技术优势</strong></h3><ol>
<li><p><strong>强大的通用性</strong></p>
<ul>
<li>大模型通过海量数据训练，具备跨领域理解和生成能力，从文本生成到代码编写、图像分析均可覆盖。</li>
<li>示例：ChatGPT能回答复杂问题、写诗、调试代码，甚至模拟特定角色的对话风格。</li>
</ul>
</li>
<li><p><strong>减少定制化成本</strong></p>
<ul>
<li>传统AI模型需针对特定任务单独训练，而大模型通过微调（Fine-tuning）或提示词（Prompt Engineering）即可适配多种任务。</li>
<li>应用案例：客服机器人、法律文档分析、医疗报告生成等场景均可基于同一模型快速开发。</li>
</ul>
</li>
<li><p><strong>推动技术民主化</strong></p>
<ul>
<li>开源社区（如Hugging Face）和云服务（如OpenAI API）降低了使用门槛，中小企业和个人开发者也能利用大模型创新。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、核心挑战"><a href="#二、核心挑战" class="headerlink" title="二、核心挑战"></a><strong>二、核心挑战</strong></h3><ol>
<li><p><strong>算力与能耗问题</strong></p>
<ul>
<li>训练大模型需数千块GPU&#x2F;TPU，能耗巨大（如GPT-3训练耗电约1,287兆瓦时），可能加剧碳足迹问题。</li>
<li>未来需依赖更高效的算法（如稀疏模型、蒸馏技术）和绿色能源支持。</li>
</ul>
</li>
<li><p><strong>数据偏见与伦理风险</strong></p>
<ul>
<li>训练数据隐含的社会偏见可能导致模型输出歧视性内容（如性别、种族偏见）。</li>
<li>需通过数据清洗、人工审核和公平性评估缓解风险。</li>
</ul>
</li>
<li><p><strong>可解释性不足</strong></p>
<ul>
<li>大模型的“黑箱”特性使其决策逻辑难以追溯，在医疗、司法等高敏感领域可能引发信任危机。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a><strong>三、应用场景</strong></h3><ol>
<li><p><strong>内容生成与创作</strong></p>
<ul>
<li>自动化写作（新闻、广告文案）、代码生成（GitHub Copilot）、艺术创作（AI绘画工具如MidJourney）。</li>
</ul>
</li>
<li><p><strong>企业效率提升</strong></p>
<ul>
<li>智能客服（24&#x2F;7响应）、数据分析（自动生成报告）、知识管理（快速检索内部文档）。</li>
</ul>
</li>
<li><p><strong>教育与科研</strong></p>
<ul>
<li>个性化教学（根据学生水平生成习题）、文献综述辅助、科学假设生成（如AlphaFold推动生物医学研究）。</li>
</ul>
</li>
<li><p><strong>医疗与公益</strong></p>
<ul>
<li>初步诊断建议、心理健康支持（如Woebot）、自然灾害预测与应急响应。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、伦理与社会影响"><a href="#四、伦理与社会影响" class="headerlink" title="四、伦理与社会影响"></a><strong>四、伦理与社会影响</strong></h3><ol>
<li><p><strong>就业结构变化</strong></p>
<ul>
<li>自动化可能替代部分重复性工作（如基础文案、客服），但也催生新职业（如提示词工程师、AI伦理顾问）。</li>
</ul>
</li>
<li><p><strong>信息真实性挑战</strong></p>
<ul>
<li>深度伪造（Deepfake）和虚假信息生成可能加剧网络信任危机，需发展检测技术与立法监管。</li>
</ul>
</li>
<li><p><strong>隐私与安全</strong></p>
<ul>
<li>模型可能记忆并泄露训练数据中的敏感信息，需通过差分隐私、数据脱敏等技术保护用户隐私。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、未来展望"><a href="#五、未来展望" class="headerlink" title="五、未来展望"></a><strong>五、未来展望</strong></h3><ol>
<li><p><strong>模型小型化与专业化</strong></p>
<ul>
<li>趋势：从“越大越好”转向高效的小模型（如TinyBERT），或通过模块化设计实现垂直领域优化。</li>
</ul>
</li>
<li><p><strong>多模态融合</strong></p>
<ul>
<li>结合文本、图像、声音的多模态模型（如GPT-4V）将推动更自然的交互方式（如具身智能、元宇宙应用）。</li>
</ul>
</li>
<li><p><strong>合规与治理</strong></p>
<ul>
<li>各国加强AI监管（如欧盟《AI法案》），推动透明性、可审计性和用户知情权。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="六、个人建议"><a href="#六、个人建议" class="headerlink" title="六、个人建议"></a><strong>六、个人建议</strong></h3><ul>
<li><strong>对开发者</strong>：关注模型的可解释性、公平性，避免技术滥用。</li>
<li><strong>对企业</strong>：优先落地高ROI场景（如客服、数据分析），同时建立AI伦理审查机制。</li>
<li><strong>对用户</strong>：理性看待AI能力边界，善用工具提升效率，警惕信息真实性。</li>
</ul>
<hr>
<p>大模型是技术发展的里程碑，但其价值取决于人类如何驾驭。唯有平衡创新与责任，才能使其真正服务于社会福祉。</p>
</li>
</ul>
<h2 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a>手撕</h2><ul>
<li><a class="link"   target="_blank" rel="noopener" href="https://codetop.cc/home" >CodeTop 面试题目总结<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>非常好，这是高频八股中的基础操作系统知识点，但很多前端候选人讲得不清楚。我们来系统地讲一下：</p>
<hr>
<h2 id="✅-一、线程-vs-进程：本质区别与联系"><a href="#✅-一、线程-vs-进程：本质区别与联系" class="headerlink" title="✅ 一、线程 vs 进程：本质区别与联系"></a>✅ 一、线程 vs 进程：本质区别与联系</h2><table>
<thead>
<tr>
<th>项目</th>
<th><strong>进程（Process）</strong></th>
<th><strong>线程（Thread）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>程序执行时的独立单位</td>
<td>进程内部的最小执行单元</td>
</tr>
<tr>
<td>拥有资源</td>
<td>拥有<strong>独立的内存空间</strong>和资源（代码段、数据段、堆栈）</td>
<td>与同一进程的线程<strong>共享内存空间</strong></td>
</tr>
<tr>
<td>通信方式</td>
<td>进程间通信（IPC）较复杂，需管道、socket、共享内存等</td>
<td>同一进程内线程直接共享变量，通信更高效</td>
</tr>
<tr>
<td>创建与销毁开销</td>
<td>大（操作系统级别）</td>
<td>小（轻量）</td>
</tr>
<tr>
<td>互不影响</td>
<td>一个进程崩溃不影响另一个</td>
<td>同一进程内，一个线程崩可能导致整个进程挂掉</td>
</tr>
<tr>
<td>举例</td>
<td>Chrome 每个 Tab 是一个独立进程</td>
<td>浏览器内资源加载、事件监听是多线程执行</td>
</tr>
</tbody></table>
<h3 id="💡-类比记忆："><a href="#💡-类比记忆：" class="headerlink" title="💡 类比记忆："></a>💡 类比记忆：</h3><ul>
<li><p><strong>进程 &#x3D; 公司部门</strong>，资源（内存）是部门的资产</p>
</li>
<li><p><strong>线程 &#x3D; 部门员工</strong>，共享资产，一人出错可能整个部门出问题</p>
</li>
</ul>
<hr>
<h2 id="✅-二、什么是死锁？"><a href="#✅-二、什么是死锁？" class="headerlink" title="✅ 二、什么是死锁？"></a>✅ 二、什么是死锁？</h2><h3 id="💬-定义："><a href="#💬-定义：" class="headerlink" title="💬 定义："></a>💬 定义：</h3><blockquote>
<p><strong>死锁</strong>是指两个或多个线程（或进程）<strong>因争夺资源而互相等待，导致程序永久卡住</strong>，且永远不会释放当前资源。</p>
</blockquote>
<hr>
<h3 id="📌-举个例子："><a href="#📌-举个例子：" class="headerlink" title="📌 举个例子："></a>📌 举个例子：</h3><p>假设有两个线程 T1 和 T2：</p>
<ol>
<li><p>T1 拿到了资源 A，想要资源 B</p>
</li>
<li><p>T2 拿到了资源 B，想要资源 A</p>
</li>
<li><p>T1 等 T2 释放 B，T2 等 T1 释放 A → 双方僵持，形成死锁。</p>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟死锁情形伪代码</span></span><br><span class="line">lock A</span><br><span class="line">  lock B  <span class="comment">// 被另一个线程占用，挂起</span></span><br><span class="line"><span class="comment">// 同时另一个线程</span></span><br><span class="line">lock B</span><br><span class="line">  lock A  <span class="comment">// 被上一个线程占用，挂起</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-死锁的四个必要条件（面试必背）："><a href="#✅-死锁的四个必要条件（面试必背）：" class="headerlink" title="✅ 死锁的四个必要条件（面试必背）："></a>✅ 死锁的四个必要条件（面试必背）：</h2><ol>
<li><p><strong>互斥</strong>：资源一次只能被一个线程使用</p>
</li>
<li><p><strong>占有且等待</strong>：已持有资源的线程继续等待其他资源</p>
</li>
<li><p><strong>不剥夺</strong>：线程获取的资源不可强制释放</p>
</li>
<li><p><strong>循环等待</strong>：多个线程形成资源等待闭环</p>
</li>
</ol>
<p>只要<strong>破坏其中一个条件</strong>，就能避免死锁。</p>
<hr>
<h2 id="✅-前端是否可能出现死锁？"><a href="#✅-前端是否可能出现死锁？" class="headerlink" title="✅ 前端是否可能出现死锁？"></a>✅ 前端是否可能出现死锁？</h2><ul>
<li><p>JS 是单线程的，不存在传统意义上的线程死锁</p>
</li>
<li><p>但 <strong>在 Web Worker &#x2F; 多 WebSocket &#x2F; 跨服务通信</strong> 场景下，<strong>可能会形成逻辑死锁</strong></p>
</li>
<li><p>比如：Worker A 等待 Worker B 消息，而 B 等待 A 的数据 → 无限循环</p>
</li>
</ul>
<h2 id="哈希表怎么解决冲突"><a href="#哈希表怎么解决冲突" class="headerlink" title="哈希表怎么解决冲突"></a>哈希表怎么解决冲突</h2><p>哈希表通过 <code>hash(key) % capacity</code> 定位存储位置，判断当前位置是否已被占用。若未被占则直接插入；若已有其他 key，则判断是否为同 key（覆盖）还是冲突（链式存储或开放寻址）。冲突处理机制决定了哈希表的效率与复杂度。</p>
<p>好问题！这是<strong>数据结构中哈希表的核心问题</strong>：<strong>哈希冲突（Hash Collision）怎么处理？</strong></p>
<p>我来给你一套完整、面试可用的标准答案 + 细节补充 + 实战联系。</p>
<hr>
<h2 id="✅-什么是哈希冲突？"><a href="#✅-什么是哈希冲突？" class="headerlink" title="✅ 什么是哈希冲突？"></a>✅ 什么是哈希冲突？</h2><blockquote>
<p>当两个不同的 key 通过 hash 函数得到相同的索引位置时，就发生了“哈希冲突”。</p>
</blockquote>
<hr>
<h2 id="✅-哈希表常见的冲突解决方法（面试必会）"><a href="#✅-哈希表常见的冲突解决方法（面试必会）" class="headerlink" title="✅ 哈希表常见的冲突解决方法（面试必会）"></a>✅ 哈希表常见的冲突解决方法（面试必会）</h2><h3 id="🔹-1-开放寻址法（Open-Addressing）"><a href="#🔹-1-开放寻址法（Open-Addressing）" class="headerlink" title="🔹 1. 开放寻址法（Open Addressing）"></a>🔹 1. 开放寻址法（Open Addressing）</h3><ul>
<li>冲突时，尝试在表内寻找下一个空位插入</li>
</ul>
<h4 id="📌-常见策略："><a href="#📌-常见策略：" class="headerlink" title="📌 常见策略："></a>📌 常见策略：</h4><table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>线性探测</td>
<td>从冲突位置向后一个一个找空位（<code>i+1, i+2, ...</code>）</td>
</tr>
<tr>
<td>二次探测</td>
<td>增量为平方（<code>i+1², i+2², ...</code>）减少聚集</td>
</tr>
<tr>
<td>双重哈希</td>
<td>冲突时使用另一个 hash 函数重新定位间隔</td>
</tr>
</tbody></table>
<h4 id="✅-优点："><a href="#✅-优点：" class="headerlink" title="✅ 优点："></a>✅ 优点：</h4><ul>
<li>不需要额外指针、结构</li>
</ul>
<h4 id="❌-缺点："><a href="#❌-缺点：" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h4><ul>
<li><p>容易造成<strong>聚集效应</strong>，查找性能下降</p>
</li>
<li><p>删除困难（要留“墓碑”）</p>
</li>
</ul>
<hr>
<h3 id="🔹-2-链地址法（Separate-Chaining）"><a href="#🔹-2-链地址法（Separate-Chaining）" class="headerlink" title="🔹 2. 链地址法（Separate Chaining）"></a>🔹 2. 链地址法（Separate Chaining）</h3><ul>
<li><p>每个数组位置不是直接存值，而是一个<strong>链表（或平衡树）</strong></p>
</li>
<li><p>所有哈希到同一位置的 key 都放在这个链表中</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table[<span class="title function_">hash</span>(key)] = [ &#123; key1, val1 &#125;, &#123; key2, val2 &#125; ]</span><br></pre></td></tr></table></figure>

<h4 id="✅-优点：-1"><a href="#✅-优点：-1" class="headerlink" title="✅ 优点："></a>✅ 优点：</h4><ul>
<li><p>冲突后插入简单，不受表容量限制</p>
</li>
<li><p>删除、插入更容易</p>
</li>
</ul>
<h4 id="❌-缺点：-1"><a href="#❌-缺点：-1" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h4><ul>
<li><p>占用额外空间（链表）</p>
</li>
<li><p>查找时间取决于链长度（极端退化为 O(n)）</p>
</li>
</ul>
<h4 id="✅-实际应用："><a href="#✅-实际应用：" class="headerlink" title="✅ 实际应用："></a>✅ 实际应用：</h4><ul>
<li><p>Java 中的 <code>HashMap</code> 就是这种方式：</p>
<ul>
<li>JDK 8 后链表长度超过阈值（默认 8）→ <strong>红黑树</strong>优化搜索效率</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🔹-3-再哈希法（Rehashing）"><a href="#🔹-3-再哈希法（Rehashing）" class="headerlink" title="🔹 3. 再哈希法（Rehashing）"></a>🔹 3. 再哈希法（Rehashing）</h3><ul>
<li><p>表容量太小时冲突增多，触发<strong>扩容</strong>（通常扩大为原来的 2 倍）</p>
</li>
<li><p>所有元素重新计算 hash 放入新表（成本较高）</p>
</li>
</ul>
<hr>
<h3 id="📌-小结对比："><a href="#📌-小结对比：" class="headerlink" title="📌 小结对比："></a>📌 小结对比：</h3><table>
<thead>
<tr>
<th>方法</th>
<th>查找</th>
<th>插入</th>
<th>空间</th>
<th>删除</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>链地址法</td>
<td>快（链短）</td>
<td>简单</td>
<td>占空间</td>
<td>简单</td>
<td>常规使用场景</td>
</tr>
<tr>
<td>开放寻址</td>
<td>慢（探测多）</td>
<td>较复杂</td>
<td>节省空间</td>
<td>麻烦</td>
<td>内存敏感</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-面试场景关联（你简历中的项目可以用上）"><a href="#✅-面试场景关联（你简历中的项目可以用上）" class="headerlink" title="✅ 面试场景关联（你简历中的项目可以用上）"></a>✅ 面试场景关联（你简历中的项目可以用上）</h2><p>你可以说：</p>
<blockquote>
<p>我在大文件上传项目中设计了 MD5 哈希索引表去做文件秒传匹配，当不同文件产生相同 MD5 时，为了安全我会用链式结构记录冲突列表，同时做大小校验或前缀对比来最终确认。</p>
</blockquote>
<hr>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>好问题！这是数据结构 + 数据库系统中的<strong>高频八股知识点</strong>，尤其是你简历中提到使用了 <strong>MySQL</strong> 和 <strong>索引优化</strong>，B+树你是绕不开的。</p>
<p>我会用<strong>一套面试官标准讲解方式</strong>帮你搞懂这两个概念、对比它们、并说明它们在项目中的实际应用场景（红黑树 → HashMap；B+树 → MySQL 索引）。</p>
<hr>
<h2 id="✅-一、什么是红黑树（Red-Black-Tree）"><a href="#✅-一、什么是红黑树（Red-Black-Tree）" class="headerlink" title="✅ 一、什么是红黑树（Red-Black Tree）"></a>✅ 一、什么是红黑树（Red-Black Tree）</h2><blockquote>
<p>红黑树是一种<strong>自平衡二叉搜索树（BST）</strong>，用于在频繁插入、删除中依然保持查找效率为 O(log n)。</p>
</blockquote>
<hr>
<h3 id="🔧-红黑树的-5-条性质（必须掌握）："><a href="#🔧-红黑树的-5-条性质（必须掌握）：" class="headerlink" title="🔧 红黑树的 5 条性质（必须掌握）："></a>🔧 红黑树的 5 条性质（必须掌握）：</h3><ol>
<li><p>每个节点要么是红色，要么是黑色</p>
</li>
<li><p>根节点是黑色</p>
</li>
<li><p>每个叶子节点（NIL）是黑色的</p>
</li>
<li><p>如果一个节点是红色的，则它的两个子节点必须是黑色的（<strong>不能连续两个红节点</strong>）</p>
</li>
<li><p>从任意节点到其叶子节点的所有路径，包含相同数量的黑色节点（<strong>黑高一致</strong>）</p>
</li>
</ol>
<hr>
<h3 id="📌-查找效率："><a href="#📌-查找效率：" class="headerlink" title="📌 查找效率："></a>📌 查找效率：</h3><ul>
<li>红黑树的深度最多为 <code>2 * log(n)</code>，保证最坏情况仍然是 O(log n)</li>
</ul>
<hr>
<h3 id="🛠-应用场景："><a href="#🛠-应用场景：" class="headerlink" title="🛠 应用场景："></a>🛠 应用场景：</h3><ul>
<li><p>Java 中的 <code>TreeMap</code>、JDK8 中 <code>HashMap</code> 桶树化后就是红黑树</p>
</li>
<li><p>Linux CFS 调度器中的任务管理树</p>
</li>
<li><p>Redis 的 <code>zset</code> 排序实现之一（跳表和红黑树可选）</p>
</li>
</ul>
<hr>
<h2 id="✅-二、什么是-B-树（数据库索引结构）"><a href="#✅-二、什么是-B-树（数据库索引结构）" class="headerlink" title="✅ 二、什么是 B+树（数据库索引结构）"></a>✅ 二、什么是 B+树（数据库索引结构）</h2><blockquote>
<p>B+树是一种<strong>多路平衡查找树</strong>，常用于<strong>数据库系统中的索引实现</strong>，MySQL InnoDB 的默认索引结构就是 B+树。</p>
</blockquote>
<hr>
<h3 id="📌-B-树结构特点："><a href="#📌-B-树结构特点：" class="headerlink" title="📌 B+树结构特点："></a>📌 B+树结构特点：</h3><ol>
<li><p><strong>每个节点可以有多个子节点（M阶树）</strong></p>
</li>
<li><p><strong>所有数据都存储在叶子节点，内部节点只存 key，用于导航</strong></p>
</li>
<li><p><strong>叶子节点之间用链表连接，支持范围扫描</strong></p>
</li>
</ol>
<hr>
<h3 id="对比普通二叉搜索树："><a href="#对比普通二叉搜索树：" class="headerlink" title="对比普通二叉搜索树："></a>对比普通二叉搜索树：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>二叉搜索树</th>
<th>B+树</th>
</tr>
</thead>
<tbody><tr>
<td>分支数</td>
<td>每个节点最多 2 个</td>
<td>每个节点可以有 M 个</td>
</tr>
<tr>
<td>层级深度</td>
<td>深（数据多时很深）</td>
<td>浅（适合磁盘 IO）</td>
</tr>
<tr>
<td>查找性能</td>
<td>O(log₂n)</td>
<td>O(logₘn) 更优</td>
</tr>
<tr>
<td>顺序遍历</td>
<td>中序遍历</td>
<td>直接顺序遍历叶子节点链表</td>
</tr>
<tr>
<td>IO 次数</td>
<td>多（每层一个磁盘页）</td>
<td>少（适合磁盘）</td>
</tr>
</tbody></table>
<hr>
<h3 id="✅-为什么数据库用-B-树，而不是红黑树？"><a href="#✅-为什么数据库用-B-树，而不是红黑树？" class="headerlink" title="✅ 为什么数据库用 B+树，而不是红黑树？"></a>✅ 为什么数据库用 B+树，而不是红黑树？</h3><table>
<thead>
<tr>
<th>原因</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>磁盘 IO 友好</td>
<td>一次读一个节点，节点可容纳上百 key，树高低，减少磁盘 seek 次数</td>
</tr>
<tr>
<td>范围查询快</td>
<td>叶子节点链表顺序遍历，无需回溯</td>
</tr>
<tr>
<td>更新性能稳定</td>
<td>不易退化，支持批量插入</td>
</tr>
</tbody></table>
<hr>
<h3 id="🧠-实际应用举例（你面试时可以说）："><a href="#🧠-实际应用举例（你面试时可以说）：" class="headerlink" title="🧠 实际应用举例（你面试时可以说）："></a>🧠 实际应用举例（你面试时可以说）：</h3><blockquote>
<p>我在 MySQL 索引优化中用 <code>EXPLAIN</code> 工具检查查询是否走了主键或联合索引，了解到底层是通过 B+树搜索。由于 B+树的所有 key 都集中在叶子节点，我在设计索引时优先让“where 条件的字段”出现在索引的前缀列，以提升匹配度和范围查询效率。</p>
</blockquote>
<hr>
<h2 id="✅-红黑树-vs-B-树-总结对比："><a href="#✅-红黑树-vs-B-树-总结对比：" class="headerlink" title="✅ 红黑树 vs B+树 总结对比："></a>✅ 红黑树 vs B+树 总结对比：</h2><table>
<thead>
<tr>
<th>特性</th>
<th>红黑树</th>
<th>B+树</th>
</tr>
</thead>
<tbody><tr>
<td>应用</td>
<td>内存数据结构（Java、Redis）</td>
<td>磁盘索引结构（MySQL）</td>
</tr>
<tr>
<td>高度</td>
<td>高（log₂n）</td>
<td>更低（logₘn）</td>
</tr>
<tr>
<td>数据存储位置</td>
<td>每个节点都存数据</td>
<td>只有叶子节点存数据</td>
</tr>
<tr>
<td>查询效率</td>
<td>log(n)</td>
<td>IO 更少，效率更高</td>
</tr>
<tr>
<td>范围查询</td>
<td>不擅长</td>
<td>非常强（链表结构）</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-如果面试时你被问："><a href="#✅-如果面试时你被问：" class="headerlink" title="✅ 如果面试时你被问："></a>✅ 如果面试时你被问：</h2><blockquote>
<p>“B+树为什么适合做数据库索引？”</p>
</blockquote>
<p>你可以这么答：</p>
<blockquote>
<p>因为数据库索引要减少磁盘 IO，B+树通过高扇出、浅层级结构降低了磁盘 seek 次数，同时叶子节点之间链表连接让范围查询非常高效。</p>
</blockquote>
<hr>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>以下是关于 <strong>并行与并发</strong> 以及 <strong>进程状态</strong> 的清晰解释，帮助你快速理解核心概念：</p>
<hr>
<h3 id="一、并行（Parallelism）-vs-并发（Concurrency）"><a href="#一、并行（Parallelism）-vs-并发（Concurrency）" class="headerlink" title="一、并行（Parallelism） vs 并发（Concurrency）"></a><strong>一、并行（Parallelism） vs 并发（Concurrency）</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>并行</strong></th>
<th><strong>并发</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td><strong>同时执行多个任务</strong>（需多核&#x2F;多CPU支持）。</td>
<td><strong>交替处理多个任务</strong>（单核即可实现）。</td>
</tr>
<tr>
<td><strong>目标</strong></td>
<td>提升性能（缩短总耗时）。</td>
<td>提高资源利用率（避免CPU空闲）。</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>多线程或多进程分配到不同核心。</td>
<td>时间片轮转（快速切换任务，看似同时执行）。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>计算密集型任务（如视频渲染、科学计算）。</td>
<td>I&#x2F;O密集型任务（如Web服务器处理多个请求）。</td>
</tr>
</tbody></table>
<h4 id="通俗比喻："><a href="#通俗比喻：" class="headerlink" title="通俗比喻："></a><strong>通俗比喻</strong>：</h4><ul>
<li><strong>并行</strong>：多个咖啡机同时制作咖啡。</li>
<li><strong>并发</strong>：一个咖啡机快速切换制作不同订单的咖啡（用户感觉“同时”进行）。</li>
</ul>
<hr>
<h3 id="二、进程的几种核心状态"><a href="#二、进程的几种核心状态" class="headerlink" title="二、进程的几种核心状态"></a><strong>二、进程的几种核心状态</strong></h3><p>进程（Process）是操作系统资源分配的基本单位。其生命周期包含以下状态：</p>
<h4 id="1-创建（New）"><a href="#1-创建（New）" class="headerlink" title="1. 创建（New）"></a><strong>1. 创建（New）</strong></h4><ul>
<li>进程正在被创建（如加载代码、分配资源）。</li>
<li>例如：双击程序图标时，操作系统为其分配内存。</li>
</ul>
<h4 id="2-就绪（Ready）"><a href="#2-就绪（Ready）" class="headerlink" title="2. 就绪（Ready）"></a><strong>2. 就绪（Ready）</strong></h4><ul>
<li>进程已准备好运行，等待CPU时间片分配。</li>
<li>例如：多个后台程序等待用户交互。</li>
</ul>
<h4 id="3-运行（Running）"><a href="#3-运行（Running）" class="headerlink" title="3. 运行（Running）"></a><strong>3. 运行（Running）</strong></h4><ul>
<li>进程正在CPU上执行指令。</li>
<li>同一时间单核CPU只能运行一个进程，多核可并行运行多个。</li>
</ul>
<h4 id="4-阻塞（Blocked-Waiting）"><a href="#4-阻塞（Blocked-Waiting）" class="headerlink" title="4. 阻塞（Blocked&#x2F;Waiting）"></a><strong>4. 阻塞（Blocked&#x2F;Waiting）</strong></h4><ul>
<li>进程因等待外部事件（如I&#x2F;O操作、用户输入）暂停执行。</li>
<li>例如：读取硬盘数据时，进程挂起直到数据就绪。</li>
</ul>
<h4 id="5-终止（Terminated）"><a href="#5-终止（Terminated）" class="headerlink" title="5. 终止（Terminated）"></a><strong>5. 终止（Terminated）</strong></h4><ul>
<li>进程执行完毕或被强制终止，释放资源。</li>
<li>例如：程序正常退出或被任务管理器关闭。</li>
</ul>
<hr>
<h3 id="三、进程状态转换图"><a href="#三、进程状态转换图" class="headerlink" title="三、进程状态转换图"></a><strong>三、进程状态转换图</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[创建 New] --&gt; B[就绪 Ready]</span><br><span class="line">    B --&gt; C[运行 Running]</span><br><span class="line">    C --&gt; B(时间片用完)</span><br><span class="line">    C --&gt; D[阻塞 Blocked]</span><br><span class="line">    D --&gt; B(等待的事件完成)</span><br><span class="line">    C --&gt; E[终止 Terminated]</span><br></pre></td></tr></table></figure>

<h4 id="关键转换条件："><a href="#关键转换条件：" class="headerlink" title="关键转换条件："></a><strong>关键转换条件</strong>：</h4><ul>
<li><strong>就绪 → 运行</strong>：进程被调度器选中。</li>
<li><strong>运行 → 就绪</strong>：时间片耗尽或被更高优先级进程抢占。</li>
<li><strong>运行 → 阻塞</strong>：主动等待资源（如调用 <code>sleep()</code> 或发起I&#x2F;O请求）。</li>
<li><strong>阻塞 → 就绪</strong>：等待的资源已就绪（如数据读取完成）。</li>
</ul>
<hr>
<h3 id="四、常见疑问解答"><a href="#四、常见疑问解答" class="headerlink" title="四、常见疑问解答"></a><strong>四、常见疑问解答</strong></h3><h4 id="1-线程和进程的区别？"><a href="#1-线程和进程的区别？" class="headerlink" title="1. 线程和进程的区别？"></a><strong>1. 线程和进程的区别？</strong></h4><ul>
<li><strong>进程</strong>：资源分配单位，独立内存空间，切换开销大。</li>
<li><strong>线程</strong>：CPU调度单位，共享进程资源，切换开销小。</li>
</ul>
<h4 id="2-单核CPU能实现并发吗？"><a href="#2-单核CPU能实现并发吗？" class="headerlink" title="2. 单核CPU能实现并发吗？"></a><strong>2. 单核CPU能实现并发吗？</strong></h4><ul>
<li><strong>能</strong>：通过快速切换（时间片轮转）模拟“同时执行”，例如同时运行音乐播放器和浏览器。</li>
</ul>
<h4 id="3-进程阻塞时CPU在做什么？"><a href="#3-进程阻塞时CPU在做什么？" class="headerlink" title="3. 进程阻塞时CPU在做什么？"></a><strong>3. 进程阻塞时CPU在做什么？</strong></h4><ul>
<li>执行其他就绪状态的进程，或进入空闲状态。</li>
</ul>
<hr>
<h3 id="五、总结-1"><a href="#五、总结-1" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><ul>
<li><strong>并行与并发</strong>：并行是物理上的同时执行，并发是逻辑上的交替执行。</li>
<li><strong>进程状态</strong>：理解状态转换有助于优化程序（如减少阻塞时间）和调试死锁问题。</li>
</ul>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"
                                   title="内网穿透"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">内网穿透</span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/IDEA%E6%89%93%E5%BC%80%E5%B7%A5%E7%A8%8B%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6/"
                                   title="IDEA打开工程不显示文件"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">IDEA打开工程不显示文件</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2025
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Keep Team</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->


<!-- lazyload -->


<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
